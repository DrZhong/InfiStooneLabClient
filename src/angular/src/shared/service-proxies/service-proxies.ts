/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param userId (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: Date | undefined, endDate: Date | undefined, userName: string | undefined, userId: number | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AuditLogListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<AuditLogListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuditLogListDtoPagedResultDto.fromJS(resultData200) : new AuditLogListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogListDtoPagedResultDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllUserFinger(): Observable<UserFingerDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetAllUserFinger";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserFinger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserFinger(<any>response_);
                } catch (e) {
                    return <Observable<UserFingerDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserFingerDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserFinger(response: HttpResponseBase): Observable<UserFingerDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserFingerDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserFingerDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUserFinger(body: UserFingerDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/AddUserFinger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserFinger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserFinger(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserFinger(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param wareHouseId (optional) 
     * @return Success
     */
    getUserWarehousePermission(wareHouseId: number | undefined): Observable<WarehousePermissionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetUserWarehousePermission?";
        if (wareHouseId === null)
            throw new Error("The parameter 'wareHouseId' cannot be null.");
        else if (wareHouseId !== undefined)
            url_ += "wareHouseId=" + encodeURIComponent("" + wareHouseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserWarehousePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserWarehousePermission(<any>response_);
                } catch (e) {
                    return <Observable<WarehousePermissionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WarehousePermissionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserWarehousePermission(response: HttpResponseBase): Observable<WarehousePermissionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WarehousePermissionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehousePermissionDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param warehouseId (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    searchStock(filter: string | undefined, warehouseId: number | undefined, pageSize: number | undefined): Observable<ClientStockDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Client/SearchStock?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "warehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchStock(<any>response_);
                } catch (e) {
                    return <Observable<ClientStockDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientStockDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchStock(response: HttpResponseBase): Observable<ClientStockDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ClientStockDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientStockDto[]>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param warehouseId (optional) 
     * @return Success
     */
    searchStockByCode(code: string | undefined, warehouseId: number | undefined): Observable<ClientStockDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Client/SearchStockByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "warehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchStockByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchStockByCode(<any>response_);
                } catch (e) {
                    return <Observable<ClientStockDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientStockDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchStockByCode(response: HttpResponseBase): Observable<ClientStockDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ClientStockDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientStockDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    stockOut(body: StockOutInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/StockOut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStockOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStockOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStockOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param barCode (optional) 
     * @param warehouseId (optional) 
     * @return Success
     */
    getReagentDetail(barCode: string | undefined, warehouseId: number | undefined): Observable<ReagentStockDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetReagentDetail?";
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "barCode=" + encodeURIComponent("" + barCode) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "warehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReagentDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReagentDetail(<any>response_);
                } catch (e) {
                    return <Observable<ReagentStockDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentStockDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReagentDetail(response: HttpResponseBase): Observable<ReagentStockDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentStockDto.fromJS(resultData200) : new ReagentStockDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentStockDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    masterStockIn(body: MasterStockInInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/MasterStockIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMasterStockIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMasterStockIn(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMasterStockIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    normalStockIn(body: MasterStockInInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/NormalStockIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNormalStockIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNormalStockIn(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNormalStockIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param barCode (optional) 
     * @return Success
     */
    getMasterStockBackDetail(barCode: string | undefined): Observable<ReagentStockDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetMasterStockBackDetail?";
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "barCode=" + encodeURIComponent("" + barCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterStockBackDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterStockBackDetail(<any>response_);
                } catch (e) {
                    return <Observable<ReagentStockDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentStockDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMasterStockBackDetail(response: HttpResponseBase): Observable<ReagentStockDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentStockDto.fromJS(resultData200) : new ReagentStockDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentStockDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    masterStockBack(body: MasterStockBackInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/MasterStockBack";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMasterStockBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMasterStockBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMasterStockBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    masterStockBackV2(body: MasterStockBackV2InputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/MasterStockBackV2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMasterStockBackV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMasterStockBackV2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMasterStockBackV2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param warehouseId (optional) 
     * @return Success
     */
    getMyOrder(warehouseId: number | undefined): Observable<OutOrderDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetMyOrder?";
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "warehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyOrder(<any>response_);
                } catch (e) {
                    return <Observable<OutOrderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutOrderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyOrder(response: HttpResponseBase): Observable<OutOrderDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OutOrderDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutOrderDto[]>(<any>null);
    }

    /**
     * @param barCode (optional) 
     * @return Success
     */
    getNormalByCode(barCode: string | undefined): Observable<NormalReagentStockListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetNormalByCode?";
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "barCode=" + encodeURIComponent("" + barCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNormalByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNormalByCode(<any>response_);
                } catch (e) {
                    return <Observable<NormalReagentStockListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NormalReagentStockListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNormalByCode(response: HttpResponseBase): Observable<NormalReagentStockListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NormalReagentStockListDto.fromJS(resultData200) : new NormalReagentStockListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NormalReagentStockListDto>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getOrderByOrderId(orderId: number | undefined): Observable<OutOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetOrderByOrderId?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderByOrderId(<any>response_);
                } catch (e) {
                    return <Observable<OutOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderByOrderId(response: HttpResponseBase): Observable<OutOrderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutOrderDto.fromJS(resultData200) : new OutOrderDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutOrderDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    outOrderStockOut(body: OutOrderStockOutInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/OutOrderStockOut";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOutOrderStockOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOutOrderStockOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOutOrderStockOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchUsers(body: PagedResultRequestFilterDto | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Common/SearchUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearchUsers(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDtoPagedResultDto.fromJS(resultData200) : new UserDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getAllActiveWareHouse(isActive: boolean | undefined): Observable<WareHouseDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetAllActiveWareHouse?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActiveWareHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActiveWareHouse(<any>response_);
                } catch (e) {
                    return <Observable<WareHouseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareHouseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllActiveWareHouse(response: HttpResponseBase): Observable<WareHouseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WareHouseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareHouseDto[]>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getMyWareActiveWareHouse(isActive: boolean | undefined): Observable<WareHouseDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetMyWareActiveWareHouse?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyWareActiveWareHouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyWareActiveWareHouse(<any>response_);
                } catch (e) {
                    return <Observable<WareHouseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareHouseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyWareActiveWareHouse(response: HttpResponseBase): Observable<WareHouseDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WareHouseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareHouseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStorageAttrList(): Observable<EnumberEntityDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetStorageAttrList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageAttrList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageAttrList(<any>response_);
                } catch (e) {
                    return <Observable<EnumberEntityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumberEntityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStorageAttrList(response: HttpResponseBase): Observable<EnumberEntityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EnumberEntityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumberEntityDto[]>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @return Success
     */
    getAllCompany(isActive: boolean | undefined): Observable<CompanyListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetAllCompany?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCompany(<any>response_);
                } catch (e) {
                    return <Observable<CompanyListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCompany(response: HttpResponseBase): Observable<CompanyListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CompanyListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPuritySelectList(): Observable<DictDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetPuritySelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPuritySelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPuritySelectList(<any>response_);
                } catch (e) {
                    return <Observable<DictDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DictDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPuritySelectList(response: HttpResponseBase): Observable<DictDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DictDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DictDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCapacityUnitSelectList(): Observable<DictDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetCapacityUnitSelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCapacityUnitSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCapacityUnitSelectList(<any>response_);
                } catch (e) {
                    return <Observable<DictDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DictDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCapacityUnitSelectList(response: HttpResponseBase): Observable<DictDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DictDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DictDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStorageConditionSelectList(): Observable<DictDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetStorageConditionSelectList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageConditionSelectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageConditionSelectList(<any>response_);
                } catch (e) {
                    return <Observable<DictDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DictDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStorageConditionSelectList(response: HttpResponseBase): Observable<DictDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DictDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DictDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getLocation(): Observable<LocationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetLocation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocation(<any>response_);
                } catch (e) {
                    return <Observable<LocationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocation(response: HttpResponseBase): Observable<LocationDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LocationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    homeMasterDto(): Observable<HomeDto> {
        let url_ = this.baseUrl + "/api/services/app/Common/HomeMasterDto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeMasterDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeMasterDto(<any>response_);
                } catch (e) {
                    return <Observable<HomeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HomeDto>><any>_observableThrow(response_);
        }));
    }

    protected processHomeMasterDto(response: HttpResponseBase): Observable<HomeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HomeDto.fromJS(resultData200) : new HomeDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeDto>(<any>null);
    }

    /**
     * @return Success
     */
    homeNormalDto(): Observable<HomeNormalDto> {
        let url_ = this.baseUrl + "/api/services/app/Common/HomeNormalDto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHomeNormalDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHomeNormalDto(<any>response_);
                } catch (e) {
                    return <Observable<HomeNormalDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HomeNormalDto>><any>_observableThrow(response_);
        }));
    }

    protected processHomeNormalDto(response: HttpResponseBase): Observable<HomeNormalDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HomeNormalDto.fromJS(resultData200) : new HomeNormalDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HomeNormalDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyDto.fromJS(resultData200) : new CompanyDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(<any>null);
    }

    /**
     * @param companyType (optional) 
     * @param contactName (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(companyType: CompanyType | undefined, contactName: string | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CompanyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetAll?";
        if (companyType === null)
            throw new Error("The parameter 'companyType' cannot be null.");
        else if (companyType !== undefined)
            url_ += "CompanyType=" + encodeURIComponent("" + companyType) + "&"; 
        if (contactName === null)
            throw new Error("The parameter 'contactName' cannot be null.");
        else if (contactName !== undefined)
            url_ += "ContactName=" + encodeURIComponent("" + contactName) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompanyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyDtoPagedResultDto.fromJS(resultData200) : new CompanyDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyDto.fromJS(resultData200) : new CompanyDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompanyDto.fromJS(resultData200) : new CompanyDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DictServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Dict/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<DictDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Dict/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DictDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DictDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DictDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DictDtoPagedResultDto.fromJS(resultData200) : new DictDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DictDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DictDto> {
        let url_ = this.baseUrl + "/api/services/app/Dict/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DictDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DictDto.fromJS(resultData200) : new DictDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DictDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: DictDto | undefined): Observable<DictDto> {
        let url_ = this.baseUrl + "/api/services/app/Dict/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DictDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DictDto.fromJS(resultData200) : new DictDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DictDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DictDto | undefined): Observable<DictDto> {
        let url_ = this.baseUrl + "/api/services/app/Dict/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DictDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DictDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DictDto.fromJS(resultData200) : new DictDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DictDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<LocationDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LocationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LocationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationDto.fromJS(resultData200) : new LocationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDto>(<any>null);
    }

    /**
     * @param warehouseId (optional) 
     * @param storageAttr (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(warehouseId: number | undefined, storageAttr: StorageAttrEnum | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<LocationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/GetAll?";
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (storageAttr === null)
            throw new Error("The parameter 'storageAttr' cannot be null.");
        else if (storageAttr !== undefined)
            url_ += "StorageAttr=" + encodeURIComponent("" + storageAttr) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<LocationDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LocationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationDtoPagedResultDto.fromJS(resultData200) : new LocationDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: LocationDto | undefined): Observable<LocationDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LocationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LocationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationDto.fromJS(resultData200) : new LocationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LocationDto | undefined): Observable<LocationDto> {
        let url_ = this.baseUrl + "/api/services/app/Location/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LocationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LocationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationDto.fromJS(resultData200) : new LocationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NormalReagentStockServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNormalStock(body: CreateNormalReagentStockDto | undefined): Observable<CreateNormalReagentStockDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/CreateNormalStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNormalStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNormalStock(<any>response_);
                } catch (e) {
                    return <Observable<CreateNormalReagentStockDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateNormalReagentStockDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNormalStock(response: HttpResponseBase): Observable<CreateNormalReagentStockDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateNormalReagentStockDto.fromJS(resultData200) : new CreateNormalReagentStockDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateNormalReagentStockDto>(<any>null);
    }

    /**
     * @param locationId (optional) 
     * @return Success
     */
    getLocationStock(locationId: number | undefined): Observable<LocationStockDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/GetLocationStock?";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationStock(<any>response_);
                } catch (e) {
                    return <Observable<LocationStockDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationStockDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationStock(response: HttpResponseBase): Observable<LocationStockDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationStockDto.fromJS(resultData200) : new LocationStockDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationStockDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param barCode (optional) 
     * @param reagentCasNo (optional) 
     * @param reagentNo (optional) 
     * @param batchNo (optional) 
     * @param supplierCompanyName (optional) 
     * @param warehouseId (optional) 
     * @param stockStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllNormal(barCode: string | undefined, reagentCasNo: string | undefined, reagentNo: string | undefined, batchNo: string | undefined, supplierCompanyName: string | undefined, warehouseId: number | undefined, stockStatus: ReagentStockStatusEnum | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NormalReagentStockListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/GetAllNormal?";
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "BarCode=" + encodeURIComponent("" + barCode) + "&"; 
        if (reagentCasNo === null)
            throw new Error("The parameter 'reagentCasNo' cannot be null.");
        else if (reagentCasNo !== undefined)
            url_ += "ReagentCasNo=" + encodeURIComponent("" + reagentCasNo) + "&"; 
        if (reagentNo === null)
            throw new Error("The parameter 'reagentNo' cannot be null.");
        else if (reagentNo !== undefined)
            url_ += "ReagentNo=" + encodeURIComponent("" + reagentNo) + "&"; 
        if (batchNo === null)
            throw new Error("The parameter 'batchNo' cannot be null.");
        else if (batchNo !== undefined)
            url_ += "BatchNo=" + encodeURIComponent("" + batchNo) + "&"; 
        if (supplierCompanyName === null)
            throw new Error("The parameter 'supplierCompanyName' cannot be null.");
        else if (supplierCompanyName !== undefined)
            url_ += "SupplierCompanyName=" + encodeURIComponent("" + supplierCompanyName) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (stockStatus === null)
            throw new Error("The parameter 'stockStatus' cannot be null.");
        else if (stockStatus !== undefined)
            url_ += "StockStatus=" + encodeURIComponent("" + stockStatus) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNormal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNormal(<any>response_);
                } catch (e) {
                    return <Observable<NormalReagentStockListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NormalReagentStockListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNormal(response: HttpResponseBase): Observable<NormalReagentStockListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NormalReagentStockListDtoPagedResultDto.fromJS(resultData200) : new NormalReagentStockListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NormalReagentStockListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param reagentNo (optional) 
     * @param barCode (optional) 
     * @param createUserName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param operateType (optional) 
     * @param warehouseId (optional) 
     * @param casNo (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getNormalReagentOperateRecord(reagentNo: string | undefined, barCode: string | undefined, createUserName: string | undefined, startDate: Date | undefined, endDate: Date | undefined, operateType: OperateTypeEnum | undefined, warehouseId: number | undefined, casNo: string | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReagentOperateRecordDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/GetNormalReagentOperateRecord?";
        if (reagentNo === null)
            throw new Error("The parameter 'reagentNo' cannot be null.");
        else if (reagentNo !== undefined)
            url_ += "ReagentNo=" + encodeURIComponent("" + reagentNo) + "&"; 
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "BarCode=" + encodeURIComponent("" + barCode) + "&"; 
        if (createUserName === null)
            throw new Error("The parameter 'createUserName' cannot be null.");
        else if (createUserName !== undefined)
            url_ += "CreateUserName=" + encodeURIComponent("" + createUserName) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (operateType === null)
            throw new Error("The parameter 'operateType' cannot be null.");
        else if (operateType !== undefined)
            url_ += "OperateType=" + encodeURIComponent("" + operateType) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (casNo === null)
            throw new Error("The parameter 'casNo' cannot be null.");
        else if (casNo !== undefined)
            url_ += "CasNo=" + encodeURIComponent("" + casNo) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNormalReagentOperateRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNormalReagentOperateRecord(<any>response_);
                } catch (e) {
                    return <Observable<ReagentOperateRecordDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentOperateRecordDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNormalReagentOperateRecord(response: HttpResponseBase): Observable<ReagentOperateRecordDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentOperateRecordDtoPagedResultDto.fromJS(resultData200) : new ReagentOperateRecordDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentOperateRecordDtoPagedResultDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getOperateRecordByNormalReagentId(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReagentOperateRecordDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/GetOperateRecordByNormalReagentId?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperateRecordByNormalReagentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperateRecordByNormalReagentId(<any>response_);
                } catch (e) {
                    return <Observable<ReagentOperateRecordDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentOperateRecordDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperateRecordByNormalReagentId(response: HttpResponseBase): Observable<ReagentOperateRecordDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentOperateRecordDtoPagedResultDto.fromJS(resultData200) : new ReagentOperateRecordDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentOperateRecordDtoPagedResultDto>(<any>null);
    }

    /**
     * @param no (optional) 
     * @param casNo (optional) 
     * @param purity (optional) 
     * @param storageCondition (optional) 
     * @param warehouseId (optional) 
     * @param stockStatus (optional) 
     * @param groupByLocationId (optional) 
     * @param stockShouldMoreZero (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getNormalReagentStock(no: string | undefined, casNo: string | undefined, purity: string | undefined, storageCondition: string | undefined, warehouseId: number | undefined, stockStatus: number | undefined, groupByLocationId: boolean | undefined, stockShouldMoreZero: boolean | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ClientStockDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/GetNormalReagentStock?";
        if (no === null)
            throw new Error("The parameter 'no' cannot be null.");
        else if (no !== undefined)
            url_ += "No=" + encodeURIComponent("" + no) + "&"; 
        if (casNo === null)
            throw new Error("The parameter 'casNo' cannot be null.");
        else if (casNo !== undefined)
            url_ += "CasNo=" + encodeURIComponent("" + casNo) + "&"; 
        if (purity === null)
            throw new Error("The parameter 'purity' cannot be null.");
        else if (purity !== undefined)
            url_ += "Purity=" + encodeURIComponent("" + purity) + "&"; 
        if (storageCondition === null)
            throw new Error("The parameter 'storageCondition' cannot be null.");
        else if (storageCondition !== undefined)
            url_ += "StorageCondition=" + encodeURIComponent("" + storageCondition) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (stockStatus === null)
            throw new Error("The parameter 'stockStatus' cannot be null.");
        else if (stockStatus !== undefined)
            url_ += "StockStatus=" + encodeURIComponent("" + stockStatus) + "&"; 
        if (groupByLocationId === null)
            throw new Error("The parameter 'groupByLocationId' cannot be null.");
        else if (groupByLocationId !== undefined)
            url_ += "GroupByLocationId=" + encodeURIComponent("" + groupByLocationId) + "&"; 
        if (stockShouldMoreZero === null)
            throw new Error("The parameter 'stockShouldMoreZero' cannot be null.");
        else if (stockShouldMoreZero !== undefined)
            url_ += "StockShouldMoreZero=" + encodeURIComponent("" + stockShouldMoreZero) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNormalReagentStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNormalReagentStock(<any>response_);
                } catch (e) {
                    return <Observable<ClientStockDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientStockDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNormalReagentStock(response: HttpResponseBase): Observable<ClientStockDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientStockDtoPagedResultDto.fromJS(resultData200) : new ClientStockDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientStockDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    gerChartData(body: GerChartDataIntputDto | undefined): Observable<GerChartDataOutDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/GerChartData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGerChartData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGerChartData(<any>response_);
                } catch (e) {
                    return <Observable<GerChartDataOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GerChartDataOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGerChartData(response: HttpResponseBase): Observable<GerChartDataOutDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GerChartDataOutDto.fromJS(resultData200) : new GerChartDataOutDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GerChartDataOutDto>(<any>null);
    }

    /**
     * @param stockStatus (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getNormalReagentStockDetailByNo(regentNo: string, stockStatus: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<NormalReagentStockListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalReagentStock/GetNormalReagentStockDetailByNo?";
        if (regentNo === undefined || regentNo === null)
            throw new Error("The parameter 'regentNo' must be defined and cannot be null.");
        else
            url_ += "RegentNo=" + encodeURIComponent("" + regentNo) + "&"; 
        if (stockStatus === null)
            throw new Error("The parameter 'stockStatus' cannot be null.");
        else if (stockStatus !== undefined)
            url_ += "StockStatus=" + encodeURIComponent("" + stockStatus) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNormalReagentStockDetailByNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNormalReagentStockDetailByNo(<any>response_);
                } catch (e) {
                    return <Observable<NormalReagentStockListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NormalReagentStockListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNormalReagentStockDetailByNo(response: HttpResponseBase): Observable<NormalReagentStockListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NormalReagentStockListDtoPagedResultDto.fromJS(resultData200) : new NormalReagentStockListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NormalReagentStockListDtoPagedResultDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: Date | undefined, endDate: Date | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserNotificationById(id: string | undefined): Observable<UserNotificationDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotificationById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotificationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotificationById(<any>response_);
                } catch (e) {
                    return <Observable<UserNotificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserNotificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotificationById(response: HttpResponseBase): Observable<UserNotificationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserNotificationDto.fromJS(resultData200) : new UserNotificationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserNotificationDto>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: GuidEntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: Date | undefined, endDate: Date | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<OrganizationUnitDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<OrganizationUnitDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDtoListResultDto.fromJS(resultData200) : new OrganizationUnitDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isOnline (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, isOnline: boolean | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<OrganizationUnitUserListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (isOnline === null)
            throw new Error("The parameter 'isOnline' cannot be null.");
        else if (isOnline !== undefined)
            url_ += "IsOnline=" + encodeURIComponent("" + isOnline) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitUserListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitUserListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<OrganizationUnitUserListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitUserListDtoPagedResultDto.fromJS(resultData200) : new OrganizationUnitUserListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitUserListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUserToOrganizationUnit(body: UserToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUserToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isInOrganizationUnit(body: UserToOrganizationUnitInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/IsInOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsInOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsInOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsInOrganizationUnit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ReagentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ReagentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Reagent/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Reagent/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ReagentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Reagent/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: GetReagentDto | undefined): Observable<ReagentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reagent/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ReagentDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReagentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentDtoPagedResultDto.fromJS(resultData200) : new ReagentDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentDtoPagedResultDto>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllDeleted(maxResultCount: number | undefined, skipCount: number | undefined): Observable<ReagentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reagent/GetAllDeleted?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDeleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDeleted(<any>response_);
                } catch (e) {
                    return <Observable<ReagentDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDeleted(response: HttpResponseBase): Observable<ReagentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentDtoPagedResultDto.fromJS(resultData200) : new ReagentDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<ReagentDto> {
        let url_ = this.baseUrl + "/api/services/app/Reagent/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<ReagentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<ReagentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentDto.fromJS(resultData200) : new ReagentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentDto>(<any>null);
    }

    /**
     * @param fileToken (optional) 
     * @return Success
     */
    excelImport(fileToken: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Reagent/ExcelImport?";
        if (fileToken === null)
            throw new Error("The parameter 'fileToken' cannot be null.");
        else if (fileToken !== undefined)
            url_ += "fileToken=" + encodeURIComponent("" + fileToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExcelImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExcelImport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processExcelImport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ReagentStockServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param barCode (optional) 
     * @param reagentCasNo (optional) 
     * @param reagentNo (optional) 
     * @param batchNo (optional) 
     * @param supplierCompanyName (optional) 
     * @param warehouseId (optional) 
     * @param stockStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMaster(barCode: string | undefined, reagentCasNo: string | undefined, reagentNo: string | undefined, batchNo: string | undefined, supplierCompanyName: string | undefined, warehouseId: number | undefined, stockStatus: ReagentStockStatusEnum | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReagentStockListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetAllMaster?";
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "BarCode=" + encodeURIComponent("" + barCode) + "&"; 
        if (reagentCasNo === null)
            throw new Error("The parameter 'reagentCasNo' cannot be null.");
        else if (reagentCasNo !== undefined)
            url_ += "ReagentCasNo=" + encodeURIComponent("" + reagentCasNo) + "&"; 
        if (reagentNo === null)
            throw new Error("The parameter 'reagentNo' cannot be null.");
        else if (reagentNo !== undefined)
            url_ += "ReagentNo=" + encodeURIComponent("" + reagentNo) + "&"; 
        if (batchNo === null)
            throw new Error("The parameter 'batchNo' cannot be null.");
        else if (batchNo !== undefined)
            url_ += "BatchNo=" + encodeURIComponent("" + batchNo) + "&"; 
        if (supplierCompanyName === null)
            throw new Error("The parameter 'supplierCompanyName' cannot be null.");
        else if (supplierCompanyName !== undefined)
            url_ += "SupplierCompanyName=" + encodeURIComponent("" + supplierCompanyName) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (stockStatus === null)
            throw new Error("The parameter 'stockStatus' cannot be null.");
        else if (stockStatus !== undefined)
            url_ += "StockStatus=" + encodeURIComponent("" + stockStatus) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaster(<any>response_);
                } catch (e) {
                    return <Observable<ReagentStockListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentStockListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMaster(response: HttpResponseBase): Observable<ReagentStockListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentStockListDtoPagedResultDto.fromJS(resultData200) : new ReagentStockListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentStockListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param locationId (optional) 
     * @return Success
     */
    getLocationStock(locationId: number | undefined): Observable<LocationStockDto> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetLocationStock?";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationStock(<any>response_);
                } catch (e) {
                    return <Observable<LocationStockDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationStockDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationStock(response: HttpResponseBase): Observable<LocationStockDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LocationStockDto.fromJS(resultData200) : new LocationStockDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationStockDto>(<any>null);
    }

    /**
     * @param barCode (optional) 
     * @param reagentCasNo (optional) 
     * @param reagentNo (optional) 
     * @param batchNo (optional) 
     * @param supplierCompanyName (optional) 
     * @param warehouseId (optional) 
     * @param stockStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param doubleConfirmed (optional) 
     * @return Success
     */
    getAllMasterDoubleConfirm(barCode: string | undefined, reagentCasNo: string | undefined, reagentNo: string | undefined, batchNo: string | undefined, supplierCompanyName: string | undefined, warehouseId: number | undefined, stockStatus: ReagentStockStatusEnum | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined, doubleConfirmed: boolean | undefined): Observable<ReagentStockListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetAllMasterDoubleConfirm?";
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "BarCode=" + encodeURIComponent("" + barCode) + "&"; 
        if (reagentCasNo === null)
            throw new Error("The parameter 'reagentCasNo' cannot be null.");
        else if (reagentCasNo !== undefined)
            url_ += "ReagentCasNo=" + encodeURIComponent("" + reagentCasNo) + "&"; 
        if (reagentNo === null)
            throw new Error("The parameter 'reagentNo' cannot be null.");
        else if (reagentNo !== undefined)
            url_ += "ReagentNo=" + encodeURIComponent("" + reagentNo) + "&"; 
        if (batchNo === null)
            throw new Error("The parameter 'batchNo' cannot be null.");
        else if (batchNo !== undefined)
            url_ += "BatchNo=" + encodeURIComponent("" + batchNo) + "&"; 
        if (supplierCompanyName === null)
            throw new Error("The parameter 'supplierCompanyName' cannot be null.");
        else if (supplierCompanyName !== undefined)
            url_ += "SupplierCompanyName=" + encodeURIComponent("" + supplierCompanyName) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (stockStatus === null)
            throw new Error("The parameter 'stockStatus' cannot be null.");
        else if (stockStatus !== undefined)
            url_ += "StockStatus=" + encodeURIComponent("" + stockStatus) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (doubleConfirmed === null)
            throw new Error("The parameter 'doubleConfirmed' cannot be null.");
        else if (doubleConfirmed !== undefined)
            url_ += "doubleConfirmed=" + encodeURIComponent("" + doubleConfirmed) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterDoubleConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterDoubleConfirm(<any>response_);
                } catch (e) {
                    return <Observable<ReagentStockListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentStockListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMasterDoubleConfirm(response: HttpResponseBase): Observable<ReagentStockListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentStockListDtoPagedResultDto.fromJS(resultData200) : new ReagentStockListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentStockListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    masterDoubleConfirm(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/MasterDoubleConfirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMasterDoubleConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMasterDoubleConfirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMasterDoubleConfirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param barCode (optional) 
     * @param reagentCasNo (optional) 
     * @param reagentNo (optional) 
     * @param batchNo (optional) 
     * @param supplierCompanyName (optional) 
     * @param warehouseId (optional) 
     * @param stockStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param clientConfirmed (optional) 
     * @return Success
     */
    getAllMasterClientConfirm(barCode: string | undefined, reagentCasNo: string | undefined, reagentNo: string | undefined, batchNo: string | undefined, supplierCompanyName: string | undefined, warehouseId: number | undefined, stockStatus: ReagentStockStatusEnum | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined, clientConfirmed: boolean | undefined): Observable<ReagentStockListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetAllMasterClientConfirm?";
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "BarCode=" + encodeURIComponent("" + barCode) + "&"; 
        if (reagentCasNo === null)
            throw new Error("The parameter 'reagentCasNo' cannot be null.");
        else if (reagentCasNo !== undefined)
            url_ += "ReagentCasNo=" + encodeURIComponent("" + reagentCasNo) + "&"; 
        if (reagentNo === null)
            throw new Error("The parameter 'reagentNo' cannot be null.");
        else if (reagentNo !== undefined)
            url_ += "ReagentNo=" + encodeURIComponent("" + reagentNo) + "&"; 
        if (batchNo === null)
            throw new Error("The parameter 'batchNo' cannot be null.");
        else if (batchNo !== undefined)
            url_ += "BatchNo=" + encodeURIComponent("" + batchNo) + "&"; 
        if (supplierCompanyName === null)
            throw new Error("The parameter 'supplierCompanyName' cannot be null.");
        else if (supplierCompanyName !== undefined)
            url_ += "SupplierCompanyName=" + encodeURIComponent("" + supplierCompanyName) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (stockStatus === null)
            throw new Error("The parameter 'stockStatus' cannot be null.");
        else if (stockStatus !== undefined)
            url_ += "StockStatus=" + encodeURIComponent("" + stockStatus) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (clientConfirmed === null)
            throw new Error("The parameter 'clientConfirmed' cannot be null.");
        else if (clientConfirmed !== undefined)
            url_ += "clientConfirmed=" + encodeURIComponent("" + clientConfirmed) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterClientConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterClientConfirm(<any>response_);
                } catch (e) {
                    return <Observable<ReagentStockListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentStockListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMasterClientConfirm(response: HttpResponseBase): Observable<ReagentStockListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentStockListDtoPagedResultDto.fromJS(resultData200) : new ReagentStockListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentStockListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    masterClientConfirm(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/MasterClientConfirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMasterClientConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMasterClientConfirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMasterClientConfirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param reagentStockId (optional) 
     * @return Success
     */
    getReagentStockAudit(reagentStockId: number | undefined): Observable<ReagentStockAuditDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetReagentStockAudit?";
        if (reagentStockId === null)
            throw new Error("The parameter 'reagentStockId' cannot be null.");
        else if (reagentStockId !== undefined)
            url_ += "reagentStockId=" + encodeURIComponent("" + reagentStockId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReagentStockAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReagentStockAudit(<any>response_);
                } catch (e) {
                    return <Observable<ReagentStockAuditDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentStockAuditDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReagentStockAudit(response: HttpResponseBase): Observable<ReagentStockAuditDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReagentStockAuditDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentStockAuditDto[]>(<any>null);
    }

    /**
     * @param num (optional) 
     * @return Success
     */
    getCodes(num: number | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetCodes?";
        if (num === null)
            throw new Error("The parameter 'num' cannot be null.");
        else if (num !== undefined)
            url_ += "num=" + encodeURIComponent("" + num) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCodes(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCodes(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMasterStock(body: CreateReagentStockDto | undefined): Observable<ReagentStockListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/CreateMasterStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMasterStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMasterStock(<any>response_);
                } catch (e) {
                    return <Observable<ReagentStockListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentStockListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMasterStock(response: HttpResponseBase): Observable<ReagentStockListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReagentStockListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentStockListDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMasterStock(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/DeleteMasterStock?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMasterStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMasterStock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMasterStock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    backMasterStock(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/BackMasterStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackMasterStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackMasterStock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBackMasterStock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param reagentNo (optional) 
     * @param barCode (optional) 
     * @param createUserName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param operateType (optional) 
     * @param warehouseId (optional) 
     * @param casNo (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getMasterReagentOperateRecord(reagentNo: string | undefined, barCode: string | undefined, createUserName: string | undefined, startDate: Date | undefined, endDate: Date | undefined, operateType: OperateTypeEnum | undefined, warehouseId: number | undefined, casNo: string | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReagentOperateRecordDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetMasterReagentOperateRecord?";
        if (reagentNo === null)
            throw new Error("The parameter 'reagentNo' cannot be null.");
        else if (reagentNo !== undefined)
            url_ += "ReagentNo=" + encodeURIComponent("" + reagentNo) + "&"; 
        if (barCode === null)
            throw new Error("The parameter 'barCode' cannot be null.");
        else if (barCode !== undefined)
            url_ += "BarCode=" + encodeURIComponent("" + barCode) + "&"; 
        if (createUserName === null)
            throw new Error("The parameter 'createUserName' cannot be null.");
        else if (createUserName !== undefined)
            url_ += "CreateUserName=" + encodeURIComponent("" + createUserName) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (operateType === null)
            throw new Error("The parameter 'operateType' cannot be null.");
        else if (operateType !== undefined)
            url_ += "OperateType=" + encodeURIComponent("" + operateType) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (casNo === null)
            throw new Error("The parameter 'casNo' cannot be null.");
        else if (casNo !== undefined)
            url_ += "CasNo=" + encodeURIComponent("" + casNo) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterReagentOperateRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterReagentOperateRecord(<any>response_);
                } catch (e) {
                    return <Observable<ReagentOperateRecordDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentOperateRecordDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMasterReagentOperateRecord(response: HttpResponseBase): Observable<ReagentOperateRecordDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentOperateRecordDtoPagedResultDto.fromJS(resultData200) : new ReagentOperateRecordDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentOperateRecordDtoPagedResultDto>(<any>null);
    }

    /**
     * @param no (optional) 
     * @param casNo (optional) 
     * @param purity (optional) 
     * @param storageCondition (optional) 
     * @param warehouseId (optional) 
     * @param stockStatus (optional) 
     * @param groupByLocationId (optional) 
     * @param stockShouldMoreZero (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getMasterReagentStock(no: string | undefined, casNo: string | undefined, purity: string | undefined, storageCondition: string | undefined, warehouseId: number | undefined, stockStatus: number | undefined, groupByLocationId: boolean | undefined, stockShouldMoreZero: boolean | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ClientStockDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetMasterReagentStock?";
        if (no === null)
            throw new Error("The parameter 'no' cannot be null.");
        else if (no !== undefined)
            url_ += "No=" + encodeURIComponent("" + no) + "&"; 
        if (casNo === null)
            throw new Error("The parameter 'casNo' cannot be null.");
        else if (casNo !== undefined)
            url_ += "CasNo=" + encodeURIComponent("" + casNo) + "&"; 
        if (purity === null)
            throw new Error("The parameter 'purity' cannot be null.");
        else if (purity !== undefined)
            url_ += "Purity=" + encodeURIComponent("" + purity) + "&"; 
        if (storageCondition === null)
            throw new Error("The parameter 'storageCondition' cannot be null.");
        else if (storageCondition !== undefined)
            url_ += "StorageCondition=" + encodeURIComponent("" + storageCondition) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (stockStatus === null)
            throw new Error("The parameter 'stockStatus' cannot be null.");
        else if (stockStatus !== undefined)
            url_ += "StockStatus=" + encodeURIComponent("" + stockStatus) + "&"; 
        if (groupByLocationId === null)
            throw new Error("The parameter 'groupByLocationId' cannot be null.");
        else if (groupByLocationId !== undefined)
            url_ += "GroupByLocationId=" + encodeURIComponent("" + groupByLocationId) + "&"; 
        if (stockShouldMoreZero === null)
            throw new Error("The parameter 'stockShouldMoreZero' cannot be null.");
        else if (stockShouldMoreZero !== undefined)
            url_ += "StockShouldMoreZero=" + encodeURIComponent("" + stockShouldMoreZero) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterReagentStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterReagentStock(<any>response_);
                } catch (e) {
                    return <Observable<ClientStockDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientStockDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMasterReagentStock(response: HttpResponseBase): Observable<ClientStockDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientStockDtoPagedResultDto.fromJS(resultData200) : new ClientStockDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientStockDtoPagedResultDto>(<any>null);
    }

    /**
     * @param stockStatus (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getMasterReagentStockDetailByNo(regentNo: string, stockStatus: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReagentStockDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GetMasterReagentStockDetailByNo?";
        if (regentNo === undefined || regentNo === null)
            throw new Error("The parameter 'regentNo' must be defined and cannot be null.");
        else
            url_ += "RegentNo=" + encodeURIComponent("" + regentNo) + "&"; 
        if (stockStatus === null)
            throw new Error("The parameter 'stockStatus' cannot be null.");
        else if (stockStatus !== undefined)
            url_ += "StockStatus=" + encodeURIComponent("" + stockStatus) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterReagentStockDetailByNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterReagentStockDetailByNo(<any>response_);
                } catch (e) {
                    return <Observable<ReagentStockDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReagentStockDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMasterReagentStockDetailByNo(response: HttpResponseBase): Observable<ReagentStockDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReagentStockDtoPagedResultDto.fromJS(resultData200) : new ReagentStockDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReagentStockDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    gerChartData(body: GerChartDataIntputDto | undefined): Observable<GerChartDataOutDto> {
        let url_ = this.baseUrl + "/api/services/app/ReagentStock/GerChartData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGerChartData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGerChartData(<any>response_);
                } catch (e) {
                    return <Observable<GerChartDataOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GerChartDataOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGerChartData(response: HttpResponseBase): Observable<GerChartDataOutDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GerChartDataOutDto.fromJS(resultData200) : new GerChartDataOutDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GerChartDataOutDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleListDtoListResultDto.fromJS(resultData200) : new RoleListDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PermissionDtoListResultDto.fromJS(resultData200) : new PermissionDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    getWarehousePermissionForEdit(roleId: number | undefined): Observable<WarehousePermissionContainer[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetWarehousePermissionForEdit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehousePermissionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehousePermissionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<WarehousePermissionContainer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WarehousePermissionContainer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarehousePermissionForEdit(response: HttpResponseBase): Observable<WarehousePermissionContainer[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WarehousePermissionContainer.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehousePermissionContainer[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateWarehousePermission(body: WarehousePermissionContainer[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/UpdateWarehousePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWarehousePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWarehousePermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWarehousePermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDtoPagedResultDto.fromJS(resultData200) : new RoleDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchCurrentUserWareHouseType(body: WarehouseType | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Session/SwitchCurrentUserWareHouseType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchCurrentUserWareHouseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchCurrentUserWareHouseType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchCurrentUserWareHouseType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class StockoutOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    cancelOrder(orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/CancelOrder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param outOrderStatus (optional) 
     * @param warehouseId (optional) 
     * @param outOrderType (optional) 
     * @param applyUserName (optional) 
     * @param inCludeItems (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllOrder(outOrderStatus: OutOrderStatusEnum | undefined, warehouseId: number | undefined, outOrderType: OutOrderTypeEnum | undefined, applyUserName: string | undefined, inCludeItems: boolean | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<OutOrderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/GetAllOrder?";
        if (outOrderStatus === null)
            throw new Error("The parameter 'outOrderStatus' cannot be null.");
        else if (outOrderStatus !== undefined)
            url_ += "OutOrderStatus=" + encodeURIComponent("" + outOrderStatus) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (outOrderType === null)
            throw new Error("The parameter 'outOrderType' cannot be null.");
        else if (outOrderType !== undefined)
            url_ += "OutOrderType=" + encodeURIComponent("" + outOrderType) + "&"; 
        if (applyUserName === null)
            throw new Error("The parameter 'applyUserName' cannot be null.");
        else if (applyUserName !== undefined)
            url_ += "ApplyUserName=" + encodeURIComponent("" + applyUserName) + "&"; 
        if (inCludeItems === null)
            throw new Error("The parameter 'inCludeItems' cannot be null.");
        else if (inCludeItems !== undefined)
            url_ += "InCludeItems=" + encodeURIComponent("" + inCludeItems) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrder(<any>response_);
                } catch (e) {
                    return <Observable<OutOrderDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutOrderDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrder(response: HttpResponseBase): Observable<OutOrderDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutOrderDtoPagedResultDto.fromJS(resultData200) : new OutOrderDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutOrderDtoPagedResultDto>(<any>null);
    }

    /**
     * @param outOrderId (optional) 
     * @return Success
     */
    getOutOrderMasterItems(outOrderId: number | undefined): Observable<OutOrderMasterItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/GetOutOrderMasterItems?";
        if (outOrderId === null)
            throw new Error("The parameter 'outOrderId' cannot be null.");
        else if (outOrderId !== undefined)
            url_ += "outOrderId=" + encodeURIComponent("" + outOrderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutOrderMasterItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutOrderMasterItems(<any>response_);
                } catch (e) {
                    return <Observable<OutOrderMasterItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutOrderMasterItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOutOrderMasterItems(response: HttpResponseBase): Observable<OutOrderMasterItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OutOrderMasterItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutOrderMasterItemDto[]>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param warehouseId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getClientConfirm(userName: string | undefined, warehouseId: number | undefined, audited: OutOrderMasterItemStatues, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AuditOutOrderMasterItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/GetClientConfirm?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (audited === undefined || audited === null)
            throw new Error("The parameter 'audited' must be defined and cannot be null.");
        else
            url_ += "Audited=" + encodeURIComponent("" + audited) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientConfirm(<any>response_);
                } catch (e) {
                    return <Observable<AuditOutOrderMasterItemDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditOutOrderMasterItemDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientConfirm(response: HttpResponseBase): Observable<AuditOutOrderMasterItemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuditOutOrderMasterItemDtoPagedResultDto.fromJS(resultData200) : new AuditOutOrderMasterItemDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditOutOrderMasterItemDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    orderClientConfirmEd(body: OrderConfirmEdInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/OrderClientConfirmEd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderClientConfirmEd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderClientConfirmEd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOrderClientConfirmEd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param warehouseId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDoubleConfirm(userName: string | undefined, warehouseId: number | undefined, audited: OutOrderMasterItemStatues, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AuditOutOrderMasterItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/GetDoubleConfirm?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (audited === undefined || audited === null)
            throw new Error("The parameter 'audited' must be defined and cannot be null.");
        else
            url_ += "Audited=" + encodeURIComponent("" + audited) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoubleConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoubleConfirm(<any>response_);
                } catch (e) {
                    return <Observable<AuditOutOrderMasterItemDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditOutOrderMasterItemDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDoubleConfirm(response: HttpResponseBase): Observable<AuditOutOrderMasterItemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuditOutOrderMasterItemDtoPagedResultDto.fromJS(resultData200) : new AuditOutOrderMasterItemDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditOutOrderMasterItemDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    doubleConfirmEd(body: OrderConfirmEdInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/DoubleConfirmEd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDoubleConfirmEd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDoubleConfirmEd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDoubleConfirmEd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param outOrderStatus (optional) 
     * @param warehouseId (optional) 
     * @param outOrderType (optional) 
     * @param applyUserName (optional) 
     * @param inCludeItems (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getMyOrder(outOrderStatus: OutOrderStatusEnum | undefined, warehouseId: number | undefined, outOrderType: OutOrderTypeEnum | undefined, applyUserName: string | undefined, inCludeItems: boolean | undefined, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<OutOrderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/GetMyOrder?";
        if (outOrderStatus === null)
            throw new Error("The parameter 'outOrderStatus' cannot be null.");
        else if (outOrderStatus !== undefined)
            url_ += "OutOrderStatus=" + encodeURIComponent("" + outOrderStatus) + "&"; 
        if (warehouseId === null)
            throw new Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (outOrderType === null)
            throw new Error("The parameter 'outOrderType' cannot be null.");
        else if (outOrderType !== undefined)
            url_ += "OutOrderType=" + encodeURIComponent("" + outOrderType) + "&"; 
        if (applyUserName === null)
            throw new Error("The parameter 'applyUserName' cannot be null.");
        else if (applyUserName !== undefined)
            url_ += "ApplyUserName=" + encodeURIComponent("" + applyUserName) + "&"; 
        if (inCludeItems === null)
            throw new Error("The parameter 'inCludeItems' cannot be null.");
        else if (inCludeItems !== undefined)
            url_ += "InCludeItems=" + encodeURIComponent("" + inCludeItems) + "&"; 
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyOrder(<any>response_);
                } catch (e) {
                    return <Observable<OutOrderDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutOrderDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyOrder(response: HttpResponseBase): Observable<OutOrderDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OutOrderDtoPagedResultDto.fromJS(resultData200) : new OutOrderDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutOrderDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOutOrder(body: CreateOutOrderInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/CreateOutOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOutOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOutOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOutOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderItemId (optional) 
     * @return Success
     */
    getOutOrderMasterItemAudit(orderItemId: number | undefined): Observable<OutOrderMasterItemAuditDto[]> {
        let url_ = this.baseUrl + "/api/services/app/StockoutOrder/GetOutOrderMasterItemAudit?";
        if (orderItemId === null)
            throw new Error("The parameter 'orderItemId' cannot be null.");
        else if (orderItemId !== undefined)
            url_ += "orderItemId=" + encodeURIComponent("" + orderItemId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutOrderMasterItemAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutOrderMasterItemAudit(<any>response_);
                } catch (e) {
                    return <Observable<OutOrderMasterItemAuditDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutOrderMasterItemAuditDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOutOrderMasterItemAudit(response: HttpResponseBase): Observable<OutOrderMasterItemAuditDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OutOrderMasterItemAuditDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutOrderMasterItemAuditDto[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDtoPagedResultDto.fromJS(resultData200) : new TenantDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    test(code: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/TokenAuth/Test?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loginByFinger(body: LoginByFingerModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LoginByFinger";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginByFinger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginByFinger(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLoginByFinger(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserFinger(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserFingerListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAllUserFinger?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserFinger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserFinger(<any>response_);
                } catch (e) {
                    return <Observable<UserFingerListDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserFingerListDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserFinger(response: HttpResponseBase): Observable<UserFingerListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserFingerListDtoPagedResultDto.fromJS(resultData200) : new UserFingerListDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserFingerListDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUserFinger(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUserFinger?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserFinger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserFinger(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserFinger(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setAsMaster(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/SetAsMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAsMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAsMaster(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAsMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelMaster(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CancelMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelMaster(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDtoListResultDto.fromJS(resultData200) : new RoleDtoListResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param isMaster (optional) 
     * @param roleId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, isMaster: boolean | undefined, roleId: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (isMaster === null)
            throw new Error("The parameter 'isMaster' cannot be null.");
        else if (isMaster !== undefined)
            url_ += "IsMaster=" + encodeURIComponent("" + isMaster) + "&"; 
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDtoPagedResultDto.fromJS(resultData200) : new UserDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class WareHouseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WareHouse/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setMaster(body: SetMasterDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WareHouse/SetMaster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetMaster(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetMaster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<WareHouseDto> {
        let url_ = this.baseUrl + "/api/services/app/WareHouse/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WareHouseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareHouseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WareHouseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WareHouseDto.fromJS(resultData200) : new WareHouseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareHouseDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAll(input: GetAll | undefined): Observable<WareHouseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WareHouse/GetAll?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<WareHouseDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareHouseDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<WareHouseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WareHouseDtoPagedResultDto.fromJS(resultData200) : new WareHouseDtoPagedResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareHouseDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: WareHouseDto | undefined): Observable<WareHouseDto> {
        let url_ = this.baseUrl + "/api/services/app/WareHouse/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<WareHouseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareHouseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WareHouseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WareHouseDto.fromJS(resultData200) : new WareHouseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareHouseDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: WareHouseDto | undefined): Observable<WareHouseDto> {
        let url_ = this.baseUrl + "/api/services/app/WareHouse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<WareHouseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WareHouseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WareHouseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WareHouseDto.fromJS(resultData200) : new WareHouseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WareHouseDto>(<any>null);
    }
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: Date;
    features!: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? new Date(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: Date;
    features: { [key: string] : boolean; } | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    id!: number;
    userId!: number | undefined;
    createUserName!: string | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: Date;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.createUserName = data["createUserName"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? new Date(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["createUserName"] = this.createUserName;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        return data; 
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    id: number;
    userId: number | undefined;
    createUserName: string | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: Date;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
}

export class AuditLogListDtoPagedResultDto implements IAuditLogListDtoPagedResultDto {
    items!: AuditLogListDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAuditLogListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): AuditLogListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AuditLogListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuditLogListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDtoPagedResultDto {
    items: AuditLogListDto[] | undefined;
    totalCount: number;
}

export class AuditOutOrderMasterItemDto implements IAuditOutOrderMasterItemDto {
    id!: number;
    price!: number;
    stockOutTime!: Date | undefined;
    outOrderId!: number;
    clientConfirm!: boolean;
    doubleConfirm!: boolean;
    clientConfirmed!: OutOrderMasterItemStatues;
    doubleConfirmed!: OutOrderMasterItemStatues;
    reagentStockId!: number | undefined;
    reagentStockBarCode!: string | undefined;
    reagentStockBatchNo!: string | undefined;
    reagentStockCapacity!: string | undefined;
    reagentStockCapacityUnit!: string | undefined;
    reagentStockSafeAttribute!: SafeAttributes;
    stockoutAccount!: number;
    reagentId!: number | undefined;
    reagentPinYinCode!: string | undefined;
    reagentCasNo!: string | undefined;
    locationId!: number | undefined;
    reagentPurity!: string | undefined;
    locationName!: string | undefined;
    reagentNo!: string | undefined;
    reagentCnName!: string | undefined;
    reagentCnAliasName!: string | undefined;
    reagentEnName!: string | undefined;
    reagentReagentCatalog!: ReagentCatalog;
    outOrderOutOrderStatus!: OutOrderStatusEnum;
    outOrderWarehouseId!: number;
    outOrderWarehouseName!: string | undefined;
    outOrderOutOrderType!: OutOrderTypeEnum;
    applyUserId!: number | undefined;
    outOrderApplyUserName!: string | undefined;
    outOrderApplyUserUserName!: string | undefined;

    constructor(data?: IAuditOutOrderMasterItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.price = data["price"];
            this.stockOutTime = data["stockOutTime"] ? new Date(data["stockOutTime"].toString()) : <any>undefined;
            this.outOrderId = data["outOrderId"];
            this.clientConfirm = data["clientConfirm"];
            this.doubleConfirm = data["doubleConfirm"];
            this.clientConfirmed = data["clientConfirmed"];
            this.doubleConfirmed = data["doubleConfirmed"];
            this.reagentStockId = data["reagentStockId"];
            this.reagentStockBarCode = data["reagentStockBarCode"];
            this.reagentStockBatchNo = data["reagentStockBatchNo"];
            this.reagentStockCapacity = data["reagentStockCapacity"];
            this.reagentStockCapacityUnit = data["reagentStockCapacityUnit"];
            this.reagentStockSafeAttribute = data["reagentStockSafeAttribute"];
            this.stockoutAccount = data["stockoutAccount"];
            this.reagentId = data["reagentId"];
            this.reagentPinYinCode = data["reagentPinYinCode"];
            this.reagentCasNo = data["reagentCasNo"];
            this.locationId = data["locationId"];
            this.reagentPurity = data["reagentPurity"];
            this.locationName = data["locationName"];
            this.reagentNo = data["reagentNo"];
            this.reagentCnName = data["reagentCnName"];
            this.reagentCnAliasName = data["reagentCnAliasName"];
            this.reagentEnName = data["reagentEnName"];
            this.reagentReagentCatalog = data["reagentReagentCatalog"];
            this.outOrderOutOrderStatus = data["outOrderOutOrderStatus"];
            this.outOrderWarehouseId = data["outOrderWarehouseId"];
            this.outOrderWarehouseName = data["outOrderWarehouseName"];
            this.outOrderOutOrderType = data["outOrderOutOrderType"];
            this.applyUserId = data["applyUserId"];
            this.outOrderApplyUserName = data["outOrderApplyUserName"];
            this.outOrderApplyUserUserName = data["outOrderApplyUserUserName"];
        }
    }

    static fromJS(data: any): AuditOutOrderMasterItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditOutOrderMasterItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["stockOutTime"] = this.stockOutTime ? this.stockOutTime.toISOString() : <any>undefined;
        data["outOrderId"] = this.outOrderId;
        data["clientConfirm"] = this.clientConfirm;
        data["doubleConfirm"] = this.doubleConfirm;
        data["clientConfirmed"] = this.clientConfirmed;
        data["doubleConfirmed"] = this.doubleConfirmed;
        data["reagentStockId"] = this.reagentStockId;
        data["reagentStockBarCode"] = this.reagentStockBarCode;
        data["reagentStockBatchNo"] = this.reagentStockBatchNo;
        data["reagentStockCapacity"] = this.reagentStockCapacity;
        data["reagentStockCapacityUnit"] = this.reagentStockCapacityUnit;
        data["reagentStockSafeAttribute"] = this.reagentStockSafeAttribute;
        data["stockoutAccount"] = this.stockoutAccount;
        data["reagentId"] = this.reagentId;
        data["reagentPinYinCode"] = this.reagentPinYinCode;
        data["reagentCasNo"] = this.reagentCasNo;
        data["locationId"] = this.locationId;
        data["reagentPurity"] = this.reagentPurity;
        data["locationName"] = this.locationName;
        data["reagentNo"] = this.reagentNo;
        data["reagentCnName"] = this.reagentCnName;
        data["reagentCnAliasName"] = this.reagentCnAliasName;
        data["reagentEnName"] = this.reagentEnName;
        data["reagentReagentCatalog"] = this.reagentReagentCatalog;
        data["outOrderOutOrderStatus"] = this.outOrderOutOrderStatus;
        data["outOrderWarehouseId"] = this.outOrderWarehouseId;
        data["outOrderWarehouseName"] = this.outOrderWarehouseName;
        data["outOrderOutOrderType"] = this.outOrderOutOrderType;
        data["applyUserId"] = this.applyUserId;
        data["outOrderApplyUserName"] = this.outOrderApplyUserName;
        data["outOrderApplyUserUserName"] = this.outOrderApplyUserUserName;
        return data; 
    }

    clone(): AuditOutOrderMasterItemDto {
        const json = this.toJSON();
        let result = new AuditOutOrderMasterItemDto();
        result.init(json);
        return result;
    }
}

export interface IAuditOutOrderMasterItemDto {
    id: number;
    price: number;
    stockOutTime: Date | undefined;
    outOrderId: number;
    clientConfirm: boolean;
    doubleConfirm: boolean;
    clientConfirmed: OutOrderMasterItemStatues;
    doubleConfirmed: OutOrderMasterItemStatues;
    reagentStockId: number | undefined;
    reagentStockBarCode: string | undefined;
    reagentStockBatchNo: string | undefined;
    reagentStockCapacity: string | undefined;
    reagentStockCapacityUnit: string | undefined;
    reagentStockSafeAttribute: SafeAttributes;
    stockoutAccount: number;
    reagentId: number | undefined;
    reagentPinYinCode: string | undefined;
    reagentCasNo: string | undefined;
    locationId: number | undefined;
    reagentPurity: string | undefined;
    locationName: string | undefined;
    reagentNo: string | undefined;
    reagentCnName: string | undefined;
    reagentCnAliasName: string | undefined;
    reagentEnName: string | undefined;
    reagentReagentCatalog: ReagentCatalog;
    outOrderOutOrderStatus: OutOrderStatusEnum;
    outOrderWarehouseId: number;
    outOrderWarehouseName: string | undefined;
    outOrderOutOrderType: OutOrderTypeEnum;
    applyUserId: number | undefined;
    outOrderApplyUserName: string | undefined;
    outOrderApplyUserUserName: string | undefined;
}

export class AuditOutOrderMasterItemDtoPagedResultDto implements IAuditOutOrderMasterItemDtoPagedResultDto {
    items!: AuditOutOrderMasterItemDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAuditOutOrderMasterItemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditOutOrderMasterItemDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): AuditOutOrderMasterItemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditOutOrderMasterItemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AuditOutOrderMasterItemDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuditOutOrderMasterItemDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuditOutOrderMasterItemDtoPagedResultDto {
    items: AuditOutOrderMasterItemDto[] | undefined;
    totalCount: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberClient!: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    userId!: number;
    userName!: string | undefined;
    userUserName!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.userUserName = data["userUserName"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userUserName"] = this.userUserName;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    userName: string | undefined;
    userUserName: string | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme!: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ClientStockDto implements IClientStockDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    clientConfirmed!: boolean;
    doubleConfirmed!: boolean;
    clientConfirm!: boolean;
    doubleConfirm!: boolean;
    no!: string;
    reagentCatalog!: ReagentCatalog;
    casNo!: string | undefined;
    reagentStatus!: ReagentStatus;
    cnName!: string;
    cnAliasName!: string | undefined;
    enName!: string | undefined;
    safeAttribute!: SafeAttributes;
    storageAttr!: StorageAttrEnum;
    pinYinCode!: string | undefined;
    purity!: string | undefined;
    capacity!: string | undefined;
    capacityUnit!: string | undefined;
    storageCondition!: string | undefined;
    inventoryWarning!: number;
    supplierCompanyId!: number | undefined;
    supplierCompanyName!: string | undefined;
    productionCompanyId!: number | undefined;
    productionCompanyName!: string | undefined;
    reagentLocations!: ReagentLocationDto[] | undefined;
    reagentLocationIds!: number[] | undefined;
    createUserName!: string | undefined;
    isMaster!: boolean;
    locationName!: string | undefined;
    locationId!: number | undefined;
    warehouseName!: string | undefined;
    lockedOutOrderId!: number | undefined;
    barCode!: string | undefined;
    num!: number;
    totalWeight!: number;
    minPrice!: number;
    maxPrice!: number;
    price!: number;
    weight!: number;

    constructor(data?: IClientStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.clientConfirmed = data["clientConfirmed"];
            this.doubleConfirmed = data["doubleConfirmed"];
            this.clientConfirm = data["clientConfirm"];
            this.doubleConfirm = data["doubleConfirm"];
            this.no = data["no"];
            this.reagentCatalog = data["reagentCatalog"];
            this.casNo = data["casNo"];
            this.reagentStatus = data["reagentStatus"];
            this.cnName = data["cnName"];
            this.cnAliasName = data["cnAliasName"];
            this.enName = data["enName"];
            this.safeAttribute = data["safeAttribute"];
            this.storageAttr = data["storageAttr"];
            this.pinYinCode = data["pinYinCode"];
            this.purity = data["purity"];
            this.capacity = data["capacity"];
            this.capacityUnit = data["capacityUnit"];
            this.storageCondition = data["storageCondition"];
            this.inventoryWarning = data["inventoryWarning"];
            this.supplierCompanyId = data["supplierCompanyId"];
            this.supplierCompanyName = data["supplierCompanyName"];
            this.productionCompanyId = data["productionCompanyId"];
            this.productionCompanyName = data["productionCompanyName"];
            if (data["reagentLocations"] && data["reagentLocations"].constructor === Array) {
                this.reagentLocations = [];
                for (let item of data["reagentLocations"])
                    this.reagentLocations.push(ReagentLocationDto.fromJS(item));
            }
            if (data["reagentLocationIds"] && data["reagentLocationIds"].constructor === Array) {
                this.reagentLocationIds = [];
                for (let item of data["reagentLocationIds"])
                    this.reagentLocationIds.push(item);
            }
            this.createUserName = data["createUserName"];
            this.isMaster = data["isMaster"];
            this.locationName = data["locationName"];
            this.locationId = data["locationId"];
            this.warehouseName = data["warehouseName"];
            this.lockedOutOrderId = data["lockedOutOrderId"];
            this.barCode = data["barCode"];
            this.num = data["num"];
            this.totalWeight = data["totalWeight"];
            this.minPrice = data["minPrice"];
            this.maxPrice = data["maxPrice"];
            this.price = data["price"];
            this.weight = data["weight"];
        }
    }

    static fromJS(data: any): ClientStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["clientConfirmed"] = this.clientConfirmed;
        data["doubleConfirmed"] = this.doubleConfirmed;
        data["clientConfirm"] = this.clientConfirm;
        data["doubleConfirm"] = this.doubleConfirm;
        data["no"] = this.no;
        data["reagentCatalog"] = this.reagentCatalog;
        data["casNo"] = this.casNo;
        data["reagentStatus"] = this.reagentStatus;
        data["cnName"] = this.cnName;
        data["cnAliasName"] = this.cnAliasName;
        data["enName"] = this.enName;
        data["safeAttribute"] = this.safeAttribute;
        data["storageAttr"] = this.storageAttr;
        data["pinYinCode"] = this.pinYinCode;
        data["purity"] = this.purity;
        data["capacity"] = this.capacity;
        data["capacityUnit"] = this.capacityUnit;
        data["storageCondition"] = this.storageCondition;
        data["inventoryWarning"] = this.inventoryWarning;
        data["supplierCompanyId"] = this.supplierCompanyId;
        data["supplierCompanyName"] = this.supplierCompanyName;
        data["productionCompanyId"] = this.productionCompanyId;
        data["productionCompanyName"] = this.productionCompanyName;
        if (this.reagentLocations && this.reagentLocations.constructor === Array) {
            data["reagentLocations"] = [];
            for (let item of this.reagentLocations)
                data["reagentLocations"].push(item.toJSON());
        }
        if (this.reagentLocationIds && this.reagentLocationIds.constructor === Array) {
            data["reagentLocationIds"] = [];
            for (let item of this.reagentLocationIds)
                data["reagentLocationIds"].push(item);
        }
        data["createUserName"] = this.createUserName;
        data["isMaster"] = this.isMaster;
        data["locationName"] = this.locationName;
        data["locationId"] = this.locationId;
        data["warehouseName"] = this.warehouseName;
        data["lockedOutOrderId"] = this.lockedOutOrderId;
        data["barCode"] = this.barCode;
        data["num"] = this.num;
        data["totalWeight"] = this.totalWeight;
        data["minPrice"] = this.minPrice;
        data["maxPrice"] = this.maxPrice;
        data["price"] = this.price;
        data["weight"] = this.weight;
        return data; 
    }

    clone(): ClientStockDto {
        const json = this.toJSON();
        let result = new ClientStockDto();
        result.init(json);
        return result;
    }
}

export interface IClientStockDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    clientConfirmed: boolean;
    doubleConfirmed: boolean;
    clientConfirm: boolean;
    doubleConfirm: boolean;
    no: string;
    reagentCatalog: ReagentCatalog;
    casNo: string | undefined;
    reagentStatus: ReagentStatus;
    cnName: string;
    cnAliasName: string | undefined;
    enName: string | undefined;
    safeAttribute: SafeAttributes;
    storageAttr: StorageAttrEnum;
    pinYinCode: string | undefined;
    purity: string | undefined;
    capacity: string | undefined;
    capacityUnit: string | undefined;
    storageCondition: string | undefined;
    inventoryWarning: number;
    supplierCompanyId: number | undefined;
    supplierCompanyName: string | undefined;
    productionCompanyId: number | undefined;
    productionCompanyName: string | undefined;
    reagentLocations: ReagentLocationDto[] | undefined;
    reagentLocationIds: number[] | undefined;
    createUserName: string | undefined;
    isMaster: boolean;
    locationName: string | undefined;
    locationId: number | undefined;
    warehouseName: string | undefined;
    lockedOutOrderId: number | undefined;
    barCode: string | undefined;
    num: number;
    totalWeight: number;
    minPrice: number;
    maxPrice: number;
    price: number;
    weight: number;
}

export class ClientStockDtoPagedResultDto implements IClientStockDtoPagedResultDto {
    items!: ClientStockDto[] | undefined;
    totalCount!: number;

    constructor(data?: IClientStockDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ClientStockDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): ClientStockDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientStockDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ClientStockDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ClientStockDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IClientStockDtoPagedResultDto {
    items: ClientStockDto[] | undefined;
    totalCount: number;
}

export class CompanyDto implements ICompanyDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    companyType!: CompanyType;
    name!: string;
    pinYin!: string | undefined;
    contactName!: string | undefined;
    contactPhone!: string | undefined;
    address!: string | undefined;
    desc!: string | undefined;
    isActive!: boolean;
    createUserName!: string | undefined;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.companyType = data["companyType"];
            this.name = data["name"];
            this.pinYin = data["pinYin"];
            this.contactName = data["contactName"];
            this.contactPhone = data["contactPhone"];
            this.address = data["address"];
            this.desc = data["desc"];
            this.isActive = data["isActive"];
            this.createUserName = data["createUserName"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["companyType"] = this.companyType;
        data["name"] = this.name;
        data["pinYin"] = this.pinYin;
        data["contactName"] = this.contactName;
        data["contactPhone"] = this.contactPhone;
        data["address"] = this.address;
        data["desc"] = this.desc;
        data["isActive"] = this.isActive;
        data["createUserName"] = this.createUserName;
        return data; 
    }

    clone(): CompanyDto {
        const json = this.toJSON();
        let result = new CompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    companyType: CompanyType;
    name: string;
    pinYin: string | undefined;
    contactName: string | undefined;
    contactPhone: string | undefined;
    address: string | undefined;
    desc: string | undefined;
    isActive: boolean;
    createUserName: string | undefined;
}

export class CompanyDtoPagedResultDto implements ICompanyDtoPagedResultDto {
    items!: CompanyDto[] | undefined;
    totalCount!: number;

    constructor(data?: ICompanyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CompanyDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): CompanyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CompanyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CompanyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDtoPagedResultDto {
    items: CompanyDto[] | undefined;
    totalCount: number;
}

export class CompanyListDto implements ICompanyListDto {
    id!: number;
    companyType!: CompanyType;
    name!: string;
    pinYin!: string | undefined;
    isActive!: boolean;

    constructor(data?: ICompanyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.companyType = data["companyType"];
            this.name = data["name"];
            this.pinYin = data["pinYin"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CompanyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyType"] = this.companyType;
        data["name"] = this.name;
        data["pinYin"] = this.pinYin;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CompanyListDto {
        const json = this.toJSON();
        let result = new CompanyListDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyListDto {
    id: number;
    companyType: CompanyType;
    name: string;
    pinYin: string | undefined;
    isActive: boolean;
}

export enum CompanyType {
    生产商 = 0, 
    供应商 = 1, 
}

export class CreateNormalReagentStockDto implements ICreateNormalReagentStockDto {
    items!: CreateNormalReagentStockItemDto[] | undefined;
    batchNo!: string;
    price!: number;
    supplierCompanyId!: number | undefined;
    productionCompanyId!: number | undefined;
    productionDate!: Date | undefined;
    expirationMonth!: number;
    expirationDate!: Date | undefined;
    reagentId!: number;

    constructor(data?: ICreateNormalReagentStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CreateNormalReagentStockItemDto.fromJS(item));
            }
            this.batchNo = data["batchNo"];
            this.price = data["price"];
            this.supplierCompanyId = data["supplierCompanyId"];
            this.productionCompanyId = data["productionCompanyId"];
            this.productionDate = data["productionDate"] ? new Date(data["productionDate"].toString()) : <any>undefined;
            this.expirationMonth = data["expirationMonth"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.reagentId = data["reagentId"];
        }
    }

    static fromJS(data: any): CreateNormalReagentStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNormalReagentStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["batchNo"] = this.batchNo;
        data["price"] = this.price;
        data["supplierCompanyId"] = this.supplierCompanyId;
        data["productionCompanyId"] = this.productionCompanyId;
        data["productionDate"] = this.productionDate ? this.productionDate.toISOString() : <any>undefined;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["reagentId"] = this.reagentId;
        return data; 
    }

    clone(): CreateNormalReagentStockDto {
        const json = this.toJSON();
        let result = new CreateNormalReagentStockDto();
        result.init(json);
        return result;
    }
}

export interface ICreateNormalReagentStockDto {
    items: CreateNormalReagentStockItemDto[] | undefined;
    batchNo: string;
    price: number;
    supplierCompanyId: number | undefined;
    productionCompanyId: number | undefined;
    productionDate: Date | undefined;
    expirationMonth: number;
    expirationDate: Date | undefined;
    reagentId: number;
}

export class CreateNormalReagentStockItemDto implements ICreateNormalReagentStockItemDto {
    locationId!: number;
    amount!: number;
    barCode!: string | undefined;

    constructor(data?: ICreateNormalReagentStockItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locationId = data["locationId"];
            this.amount = data["amount"];
            this.barCode = data["barCode"];
        }
    }

    static fromJS(data: any): CreateNormalReagentStockItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNormalReagentStockItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId;
        data["amount"] = this.amount;
        data["barCode"] = this.barCode;
        return data; 
    }

    clone(): CreateNormalReagentStockItemDto {
        const json = this.toJSON();
        let result = new CreateNormalReagentStockItemDto();
        result.init(json);
        return result;
    }
}

export interface ICreateNormalReagentStockItemDto {
    locationId: number;
    amount: number;
    barCode: string | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;
    sort!: number;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
            this.sort = data["sort"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["sort"] = this.sort;
        return data; 
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
    sort: number;
}

export class CreateOutOrderInputDto implements ICreateOutOrderInputDto {
    outOrderType!: OutOrderTypeEnum;
    warehouseId!: number;
    applyUserName!: string | undefined;
    items!: CreateOutOrderItem[] | undefined;

    constructor(data?: ICreateOutOrderInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.outOrderType = data["outOrderType"];
            this.warehouseId = data["warehouseId"];
            this.applyUserName = data["applyUserName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CreateOutOrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOutOrderInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOutOrderInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outOrderType"] = this.outOrderType;
        data["warehouseId"] = this.warehouseId;
        data["applyUserName"] = this.applyUserName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOutOrderInputDto {
        const json = this.toJSON();
        let result = new CreateOutOrderInputDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOutOrderInputDto {
    outOrderType: OutOrderTypeEnum;
    warehouseId: number;
    applyUserName: string | undefined;
    items: CreateOutOrderItem[] | undefined;
}

export class CreateOutOrderItem implements ICreateOutOrderItem {
    reagentStockId!: number | undefined;
    stockoutAccount!: number;
    reagentId!: number | undefined;
    locationId!: number | undefined;

    constructor(data?: ICreateOutOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reagentStockId = data["reagentStockId"];
            this.stockoutAccount = data["stockoutAccount"];
            this.reagentId = data["reagentId"];
            this.locationId = data["locationId"];
        }
    }

    static fromJS(data: any): CreateOutOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOutOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reagentStockId"] = this.reagentStockId;
        data["stockoutAccount"] = this.stockoutAccount;
        data["reagentId"] = this.reagentId;
        data["locationId"] = this.locationId;
        return data; 
    }

    clone(): CreateOutOrderItem {
        const json = this.toJSON();
        let result = new CreateOutOrderItem();
        result.init(json);
        return result;
    }
}

export interface ICreateOutOrderItem {
    reagentStockId: number | undefined;
    stockoutAccount: number;
    reagentId: number | undefined;
    locationId: number | undefined;
}

export class CreateReagentStockDto implements ICreateReagentStockDto {
    codes!: string[] | undefined;
    batchNo!: string;
    locationId!: number;
    supplierCompanyId!: number | undefined;
    productionCompanyId!: number | undefined;
    productionDate!: Date | undefined;
    expirationMonth!: number;
    expirationDate!: Date | undefined;
    clientConfirm!: boolean;
    doubleConfirm!: boolean;
    reagentId!: number;
    price!: number;

    constructor(data?: ICreateReagentStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["codes"] && data["codes"].constructor === Array) {
                this.codes = [];
                for (let item of data["codes"])
                    this.codes.push(item);
            }
            this.batchNo = data["batchNo"];
            this.locationId = data["locationId"];
            this.supplierCompanyId = data["supplierCompanyId"];
            this.productionCompanyId = data["productionCompanyId"];
            this.productionDate = data["productionDate"] ? new Date(data["productionDate"].toString()) : <any>undefined;
            this.expirationMonth = data["expirationMonth"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.clientConfirm = data["clientConfirm"];
            this.doubleConfirm = data["doubleConfirm"];
            this.reagentId = data["reagentId"];
            this.price = data["price"];
        }
    }

    static fromJS(data: any): CreateReagentStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReagentStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.codes && this.codes.constructor === Array) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["batchNo"] = this.batchNo;
        data["locationId"] = this.locationId;
        data["supplierCompanyId"] = this.supplierCompanyId;
        data["productionCompanyId"] = this.productionCompanyId;
        data["productionDate"] = this.productionDate ? this.productionDate.toISOString() : <any>undefined;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["clientConfirm"] = this.clientConfirm;
        data["doubleConfirm"] = this.doubleConfirm;
        data["reagentId"] = this.reagentId;
        data["price"] = this.price;
        return data; 
    }

    clone(): CreateReagentStockDto {
        const json = this.toJSON();
        let result = new CreateReagentStockDto();
        result.init(json);
        return result;
    }
}

export interface ICreateReagentStockDto {
    codes: string[] | undefined;
    batchNo: string;
    locationId: number;
    supplierCompanyId: number | undefined;
    productionCompanyId: number | undefined;
    productionDate: Date | undefined;
    expirationMonth: number;
    expirationDate: Date | undefined;
    clientConfirm: boolean;
    doubleConfirm: boolean;
    reagentId: number;
    price: number;
}

export class CreateRoleDto implements ICreateRoleDto {
    name!: string;
    displayName!: string;
    normalizedName!: string | undefined;
    description!: string | undefined;
    grantedPermissions!: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["grantedPermissions"] && data["grantedPermissions"].constructor === Array) {
                this.grantedPermissions = [];
                for (let item of data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.grantedPermissions && this.grantedPermissions.constructor === Array) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    connectionString!: string | undefined;
    isActive!: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName!: string;
    name!: string;
    surname!: string | undefined;
    emailAddress!: string | undefined;
    isActive!: boolean;
    roleNames!: string[] | undefined;
    password!: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class DictDto implements IDictDto {
    id!: number;
    name!: string;
    value!: string | undefined;
    sort!: number;
    parentId!: number | undefined;
    child!: DictDto[] | undefined;
    createUserName!: string | undefined;

    constructor(data?: IDictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.value = data["value"];
            this.sort = data["sort"];
            this.parentId = data["parentId"];
            if (data["child"] && data["child"].constructor === Array) {
                this.child = [];
                for (let item of data["child"])
                    this.child.push(DictDto.fromJS(item));
            }
            this.createUserName = data["createUserName"];
        }
    }

    static fromJS(data: any): DictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["sort"] = this.sort;
        data["parentId"] = this.parentId;
        if (this.child && this.child.constructor === Array) {
            data["child"] = [];
            for (let item of this.child)
                data["child"].push(item.toJSON());
        }
        data["createUserName"] = this.createUserName;
        return data; 
    }

    clone(): DictDto {
        const json = this.toJSON();
        let result = new DictDto();
        result.init(json);
        return result;
    }
}

export interface IDictDto {
    id: number;
    name: string;
    value: string | undefined;
    sort: number;
    parentId: number | undefined;
    child: DictDto[] | undefined;
    createUserName: string | undefined;
}

export class DictDtoPagedResultDto implements IDictDtoPagedResultDto {
    items!: DictDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDictDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DictDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): DictDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DictDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DictDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDictDtoPagedResultDto {
    items: DictDto[] | undefined;
    totalCount: number;
}

export class EntityDto implements IEntityDto {
    id!: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number;
}

export class EnumberEntityDto implements IEnumberEntityDto {
    desction!: string | undefined;
    enumName!: string | undefined;
    enumValue!: number;

    constructor(data?: IEnumberEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desction = data["desction"];
            this.enumName = data["enumName"];
            this.enumValue = data["enumValue"];
        }
    }

    static fromJS(data: any): EnumberEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumberEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desction"] = this.desction;
        data["enumName"] = this.enumName;
        data["enumValue"] = this.enumValue;
        return data; 
    }

    clone(): EnumberEntityDto {
        const json = this.toJSON();
        let result = new EnumberEntityDto();
        result.init(json);
        return result;
    }
}

export interface IEnumberEntityDto {
    desction: string | undefined;
    enumName: string | undefined;
    enumValue: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name!: string | undefined;
    parentName!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.parentName = data["parentName"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentName"] = this.parentName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    parentName: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GerChartDataIntputDto implements IGerChartDataIntputDto {
    dateCurrent!: string | undefined;
    endDate!: Date | undefined;
    startDate!: Date | undefined;
    groupBy!: number;
    masterType!: boolean;
    safeAttributes!: SafeAttributes;
    reagentId!: number | undefined;

    constructor(data?: IGerChartDataIntputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateCurrent = data["dateCurrent"];
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.groupBy = data["groupBy"];
            this.masterType = data["masterType"];
            this.safeAttributes = data["safeAttributes"];
            this.reagentId = data["reagentId"];
        }
    }

    static fromJS(data: any): GerChartDataIntputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GerChartDataIntputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateCurrent"] = this.dateCurrent;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["groupBy"] = this.groupBy;
        data["masterType"] = this.masterType;
        data["safeAttributes"] = this.safeAttributes;
        data["reagentId"] = this.reagentId;
        return data; 
    }

    clone(): GerChartDataIntputDto {
        const json = this.toJSON();
        let result = new GerChartDataIntputDto();
        result.init(json);
        return result;
    }
}

export interface IGerChartDataIntputDto {
    dateCurrent: string | undefined;
    endDate: Date | undefined;
    startDate: Date | undefined;
    groupBy: number;
    masterType: boolean;
    safeAttributes: SafeAttributes;
    reagentId: number | undefined;
}

export class GerChartDataOutDto implements IGerChartDataOutDto {
    time!: string[] | undefined;
    stockIn!: number[] | undefined;
    stockOut!: number[] | undefined;
    stockBack!: number[] | undefined;
    stockRetrieve!: number[] | undefined;

    constructor(data?: IGerChartDataOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["time"] && data["time"].constructor === Array) {
                this.time = [];
                for (let item of data["time"])
                    this.time.push(item);
            }
            if (data["stockIn"] && data["stockIn"].constructor === Array) {
                this.stockIn = [];
                for (let item of data["stockIn"])
                    this.stockIn.push(item);
            }
            if (data["stockOut"] && data["stockOut"].constructor === Array) {
                this.stockOut = [];
                for (let item of data["stockOut"])
                    this.stockOut.push(item);
            }
            if (data["stockBack"] && data["stockBack"].constructor === Array) {
                this.stockBack = [];
                for (let item of data["stockBack"])
                    this.stockBack.push(item);
            }
            if (data["stockRetrieve"] && data["stockRetrieve"].constructor === Array) {
                this.stockRetrieve = [];
                for (let item of data["stockRetrieve"])
                    this.stockRetrieve.push(item);
            }
        }
    }

    static fromJS(data: any): GerChartDataOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new GerChartDataOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.time && this.time.constructor === Array) {
            data["time"] = [];
            for (let item of this.time)
                data["time"].push(item);
        }
        if (this.stockIn && this.stockIn.constructor === Array) {
            data["stockIn"] = [];
            for (let item of this.stockIn)
                data["stockIn"].push(item);
        }
        if (this.stockOut && this.stockOut.constructor === Array) {
            data["stockOut"] = [];
            for (let item of this.stockOut)
                data["stockOut"].push(item);
        }
        if (this.stockBack && this.stockBack.constructor === Array) {
            data["stockBack"] = [];
            for (let item of this.stockBack)
                data["stockBack"].push(item);
        }
        if (this.stockRetrieve && this.stockRetrieve.constructor === Array) {
            data["stockRetrieve"] = [];
            for (let item of this.stockRetrieve)
                data["stockRetrieve"].push(item);
        }
        return data; 
    }

    clone(): GerChartDataOutDto {
        const json = this.toJSON();
        let result = new GerChartDataOutDto();
        result.init(json);
        return result;
    }
}

export interface IGerChartDataOutDto {
    time: string[] | undefined;
    stockIn: number[] | undefined;
    stockOut: number[] | undefined;
    stockBack: number[] | undefined;
    stockRetrieve: number[] | undefined;
}

export class GetAll implements IGetAll {

    constructor(data?: IGetAll) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): GetAll {
        data = typeof data === 'object' ? data : {};
        let result = new GetAll();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): GetAll {
        const json = this.toJSON();
        let result = new GetAll();
        result.init(json);
        return result;
    }
}

export interface IGetAll {
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application!: ApplicationInfoDto;
    user!: UserLoginInfoDto;
    canManageReagent!: boolean;
    canManageConsum!: boolean;
    canManageOffice!: boolean;
    tenant!: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.application = new ApplicationInfoDto();
            this.user = new UserLoginInfoDto();
            this.tenant = new TenantLoginInfoDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : new ApplicationInfoDto();
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : new UserLoginInfoDto();
            this.canManageReagent = data["canManageReagent"];
            this.canManageConsum = data["canManageConsum"];
            this.canManageOffice = data["canManageOffice"];
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : new TenantLoginInfoDto();
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["canManageReagent"] = this.canManageReagent;
        data["canManageConsum"] = this.canManageConsum;
        data["canManageOffice"] = this.canManageOffice;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    canManageReagent: boolean;
    canManageConsum: boolean;
    canManageOffice: boolean;
    tenant: TenantLoginInfoDto;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationSettingsOutput {
        const json = this.toJSON();
        let result = new GetNotificationSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    items!: UserNotificationDto[] | undefined;
    totalCount!: number;
    unreadCount!: number;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotificationDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
            this.unreadCount = data["unreadCount"];
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["unreadCount"] = this.unreadCount;
        return data; 
    }

    clone(): GetNotificationsOutput {
        const json = this.toJSON();
        let result = new GetNotificationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationsOutput {
    items: UserNotificationDto[] | undefined;
    totalCount: number;
    unreadCount: number;
}

export class GetReagentDto implements IGetReagentDto {
    filter!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;
    no!: string | undefined;
    casNo!: string | undefined;
    supplierCompanyName!: string | undefined;
    productionCompanyName!: string | undefined;
    reagentCatalogs!: ReagentCatalog[] | undefined;
    reagentStatus!: ReagentStatus;

    constructor(data?: IGetReagentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
            this.no = data["no"];
            this.casNo = data["casNo"];
            this.supplierCompanyName = data["supplierCompanyName"];
            this.productionCompanyName = data["productionCompanyName"];
            if (data["reagentCatalogs"] && data["reagentCatalogs"].constructor === Array) {
                this.reagentCatalogs = [];
                for (let item of data["reagentCatalogs"])
                    this.reagentCatalogs.push(item);
            }
            this.reagentStatus = data["reagentStatus"];
        }
    }

    static fromJS(data: any): GetReagentDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReagentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        data["no"] = this.no;
        data["casNo"] = this.casNo;
        data["supplierCompanyName"] = this.supplierCompanyName;
        data["productionCompanyName"] = this.productionCompanyName;
        if (this.reagentCatalogs && this.reagentCatalogs.constructor === Array) {
            data["reagentCatalogs"] = [];
            for (let item of this.reagentCatalogs)
                data["reagentCatalogs"].push(item);
        }
        data["reagentStatus"] = this.reagentStatus;
        return data; 
    }

    clone(): GetReagentDto {
        const json = this.toJSON();
        let result = new GetReagentDto();
        result.init(json);
        return result;
    }
}

export interface IGetReagentDto {
    filter: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
    no: string | undefined;
    casNo: string | undefined;
    supplierCompanyName: string | undefined;
    productionCompanyName: string | undefined;
    reagentCatalogs: ReagentCatalog[] | undefined;
    reagentStatus: ReagentStatus;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GuidEntityDto implements IGuidEntityDto {
    id!: string;

    constructor(data?: IGuidEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GuidEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuidEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): GuidEntityDto {
        const json = this.toJSON();
        let result = new GuidEntityDto();
        result.init(json);
        return result;
    }
}

export interface IGuidEntityDto {
    id: string;
}

export class HomeDto implements IHomeDto {
    master!: HomeMasterDto;
    normal!: HomeNormalDto;

    constructor(data?: IHomeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.master = new HomeMasterDto();
            this.normal = new HomeNormalDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.master = data["master"] ? HomeMasterDto.fromJS(data["master"]) : new HomeMasterDto();
            this.normal = data["normal"] ? HomeNormalDto.fromJS(data["normal"]) : new HomeNormalDto();
        }
    }

    static fromJS(data: any): HomeDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["master"] = this.master ? this.master.toJSON() : <any>undefined;
        data["normal"] = this.normal ? this.normal.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HomeDto {
        const json = this.toJSON();
        let result = new HomeDto();
        result.init(json);
        return result;
    }
}

export interface IHomeDto {
    master: HomeMasterDto;
    normal: HomeNormalDto;
}

export class HomeMasterDto implements IHomeMasterDto {
    todayStockOutCount!: number;
    todayStockBackCount!: number;
    todayStockInCount!: number;
    todayStockRetrieveCount!: number;
    regentInventoryWarningCount!: number;
    expirationCount!: number;

    constructor(data?: IHomeMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.todayStockOutCount = data["todayStockOutCount"];
            this.todayStockBackCount = data["todayStockBackCount"];
            this.todayStockInCount = data["todayStockInCount"];
            this.todayStockRetrieveCount = data["todayStockRetrieveCount"];
            this.regentInventoryWarningCount = data["regentInventoryWarningCount"];
            this.expirationCount = data["expirationCount"];
        }
    }

    static fromJS(data: any): HomeMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["todayStockOutCount"] = this.todayStockOutCount;
        data["todayStockBackCount"] = this.todayStockBackCount;
        data["todayStockInCount"] = this.todayStockInCount;
        data["todayStockRetrieveCount"] = this.todayStockRetrieveCount;
        data["regentInventoryWarningCount"] = this.regentInventoryWarningCount;
        data["expirationCount"] = this.expirationCount;
        return data; 
    }

    clone(): HomeMasterDto {
        const json = this.toJSON();
        let result = new HomeMasterDto();
        result.init(json);
        return result;
    }
}

export interface IHomeMasterDto {
    todayStockOutCount: number;
    todayStockBackCount: number;
    todayStockInCount: number;
    todayStockRetrieveCount: number;
    regentInventoryWarningCount: number;
    expirationCount: number;
}

export class HomeNormalDto implements IHomeNormalDto {
    todayStockOutCount!: number;
    todayStockBackCount!: number;
    todayStockInCount!: number;
    regentInventoryWarningCount!: number;
    expirationCount!: number;

    constructor(data?: IHomeNormalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.todayStockOutCount = data["todayStockOutCount"];
            this.todayStockBackCount = data["todayStockBackCount"];
            this.todayStockInCount = data["todayStockInCount"];
            this.regentInventoryWarningCount = data["regentInventoryWarningCount"];
            this.expirationCount = data["expirationCount"];
        }
    }

    static fromJS(data: any): HomeNormalDto {
        data = typeof data === 'object' ? data : {};
        let result = new HomeNormalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["todayStockOutCount"] = this.todayStockOutCount;
        data["todayStockBackCount"] = this.todayStockBackCount;
        data["todayStockInCount"] = this.todayStockInCount;
        data["regentInventoryWarningCount"] = this.regentInventoryWarningCount;
        data["expirationCount"] = this.expirationCount;
        return data; 
    }

    clone(): HomeNormalDto {
        const json = this.toJSON();
        let result = new HomeNormalDto();
        result.init(json);
        return result;
    }
}

export interface IHomeNormalDto {
    todayStockOutCount: number;
    todayStockBackCount: number;
    todayStockInCount: number;
    regentInventoryWarningCount: number;
    expirationCount: number;
}

export class Int64EntityDto implements IInt64EntityDto {
    id!: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class LocationDto implements ILocationDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    shelfNo!: string | undefined;
    row!: number;
    column!: number;
    name!: string | undefined;
    sort!: number;
    warehouseId!: number;
    warehouseName!: string | undefined;
    createUserName!: string | undefined;
    isActive!: boolean;
    countLimit!: number;
    locationStorageAttr!: LocationStorageAttrDto[] | undefined;

    constructor(data?: ILocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.shelfNo = data["shelfNo"];
            this.row = data["row"];
            this.column = data["column"];
            this.name = data["name"];
            this.sort = data["sort"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.createUserName = data["createUserName"];
            this.isActive = data["isActive"];
            this.countLimit = data["countLimit"];
            if (data["locationStorageAttr"] && data["locationStorageAttr"].constructor === Array) {
                this.locationStorageAttr = [];
                for (let item of data["locationStorageAttr"])
                    this.locationStorageAttr.push(LocationStorageAttrDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["shelfNo"] = this.shelfNo;
        data["row"] = this.row;
        data["column"] = this.column;
        data["name"] = this.name;
        data["sort"] = this.sort;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["createUserName"] = this.createUserName;
        data["isActive"] = this.isActive;
        data["countLimit"] = this.countLimit;
        if (this.locationStorageAttr && this.locationStorageAttr.constructor === Array) {
            data["locationStorageAttr"] = [];
            for (let item of this.locationStorageAttr)
                data["locationStorageAttr"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocationDto {
        const json = this.toJSON();
        let result = new LocationDto();
        result.init(json);
        return result;
    }
}

export interface ILocationDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    shelfNo: string | undefined;
    row: number;
    column: number;
    name: string | undefined;
    sort: number;
    warehouseId: number;
    warehouseName: string | undefined;
    createUserName: string | undefined;
    isActive: boolean;
    countLimit: number;
    locationStorageAttr: LocationStorageAttrDto[] | undefined;
}

export class LocationDtoPagedResultDto implements ILocationDtoPagedResultDto {
    items!: LocationDto[] | undefined;
    totalCount!: number;

    constructor(data?: ILocationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocationDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): LocationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): LocationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LocationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILocationDtoPagedResultDto {
    items: LocationDto[] | undefined;
    totalCount: number;
}

export class LocationStockDto implements ILocationStockDto {
    countLimit!: number;
    exitStockCount!: number;
    outStockCount!: number;

    constructor(data?: ILocationStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countLimit = data["countLimit"];
            this.exitStockCount = data["exitStockCount"];
            this.outStockCount = data["outStockCount"];
        }
    }

    static fromJS(data: any): LocationStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countLimit"] = this.countLimit;
        data["exitStockCount"] = this.exitStockCount;
        data["outStockCount"] = this.outStockCount;
        return data; 
    }

    clone(): LocationStockDto {
        const json = this.toJSON();
        let result = new LocationStockDto();
        result.init(json);
        return result;
    }
}

export interface ILocationStockDto {
    countLimit: number;
    exitStockCount: number;
    outStockCount: number;
}

export class LocationStorageAttrDto implements ILocationStorageAttrDto {
    id!: number;
    locationId!: number;
    storageAttr!: StorageAttrEnum;
    storageAttrToString!: string | undefined;
    isActive!: boolean;

    constructor(data?: ILocationStorageAttrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.locationId = data["locationId"];
            this.storageAttr = data["storageAttr"];
            this.storageAttrToString = data["storageAttrToString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): LocationStorageAttrDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationStorageAttrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["locationId"] = this.locationId;
        data["storageAttr"] = this.storageAttr;
        data["storageAttrToString"] = this.storageAttrToString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): LocationStorageAttrDto {
        const json = this.toJSON();
        let result = new LocationStorageAttrDto();
        result.init(json);
        return result;
    }
}

export interface ILocationStorageAttrDto {
    id: number;
    locationId: number;
    storageAttr: StorageAttrEnum;
    storageAttrToString: string | undefined;
    isActive: boolean;
}

export class LoginByFingerModel implements ILoginByFingerModel {
    code!: string;

    constructor(data?: ILoginByFingerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): LoginByFingerModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginByFingerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }

    clone(): LoginByFingerModel {
        const json = this.toJSON();
        let result = new LoginByFingerModel();
        result.init(json);
        return result;
    }
}

export interface ILoginByFingerModel {
    code: string;
}

export class MasterStockBackInputDto implements IMasterStockBackInputDto {
    reagentStockIds!: number[] | undefined;
    warehouseId!: number;

    constructor(data?: IMasterStockBackInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["reagentStockIds"] && data["reagentStockIds"].constructor === Array) {
                this.reagentStockIds = [];
                for (let item of data["reagentStockIds"])
                    this.reagentStockIds.push(item);
            }
            this.warehouseId = data["warehouseId"];
        }
    }

    static fromJS(data: any): MasterStockBackInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterStockBackInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.reagentStockIds && this.reagentStockIds.constructor === Array) {
            data["reagentStockIds"] = [];
            for (let item of this.reagentStockIds)
                data["reagentStockIds"].push(item);
        }
        data["warehouseId"] = this.warehouseId;
        return data; 
    }

    clone(): MasterStockBackInputDto {
        const json = this.toJSON();
        let result = new MasterStockBackInputDto();
        result.init(json);
        return result;
    }
}

export interface IMasterStockBackInputDto {
    reagentStockIds: number[] | undefined;
    warehouseId: number;
}

export class MasterStockBackV2InputDto implements IMasterStockBackV2InputDto {
    weight!: number;
    reagentStockId!: number;
    warehouseId!: number;

    constructor(data?: IMasterStockBackV2InputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.weight = data["weight"];
            this.reagentStockId = data["reagentStockId"];
            this.warehouseId = data["warehouseId"];
        }
    }

    static fromJS(data: any): MasterStockBackV2InputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterStockBackV2InputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weight"] = this.weight;
        data["reagentStockId"] = this.reagentStockId;
        data["warehouseId"] = this.warehouseId;
        return data; 
    }

    clone(): MasterStockBackV2InputDto {
        const json = this.toJSON();
        let result = new MasterStockBackV2InputDto();
        result.init(json);
        return result;
    }
}

export interface IMasterStockBackV2InputDto {
    weight: number;
    reagentStockId: number;
    warehouseId: number;
}

export class MasterStockInInputDto implements IMasterStockInInputDto {
    reagentStockId!: number;
    warehouseId!: number;
    acount!: number;
    weight!: number;

    constructor(data?: IMasterStockInInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reagentStockId = data["reagentStockId"];
            this.warehouseId = data["warehouseId"];
            this.acount = data["acount"];
            this.weight = data["weight"];
        }
    }

    static fromJS(data: any): MasterStockInInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterStockInInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reagentStockId"] = this.reagentStockId;
        data["warehouseId"] = this.warehouseId;
        data["acount"] = this.acount;
        data["weight"] = this.weight;
        return data; 
    }

    clone(): MasterStockInInputDto {
        const json = this.toJSON();
        let result = new MasterStockInInputDto();
        result.init(json);
        return result;
    }
}

export interface IMasterStockInInputDto {
    reagentStockId: number;
    warehouseId: number;
    acount: number;
    weight: number;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class NormalReagentStockListDto implements INormalReagentStockListDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    amount!: number;
    realAmount!: number;
    barCode!: string | undefined;
    batchNo!: string | undefined;
    productionDate!: Date | undefined;
    expirationMonth!: number;
    expirationDate!: Date;
    locationId!: number;
    locationName!: string | undefined;
    warehouseId!: number;
    warehouseName!: string | undefined;
    supplierCompanyId!: number | undefined;
    supplierCompanyName!: string | undefined;
    productionCompanyId!: number | undefined;
    productionCompanyName!: string | undefined;
    stockStatus!: ReagentStockStatusEnum;
    reagentId!: number;
    reagentCasNo!: string | undefined;
    reagentNo!: string | undefined;
    reagentCnName!: string | undefined;
    reagentCnAliasName!: string | undefined;
    reagentEnName!: string | undefined;
    reagentPurity!: string | undefined;
    pinYinCode!: string | undefined;
    casNo!: string | undefined;
    createUserName!: string | undefined;
    capacity!: string | undefined;
    stockInTime!: Date | undefined;
    latestStockInTime!: Date | undefined;
    latestStockInUserName!: string | undefined;
    latestStockOutTime!: Date | undefined;
    latestStockOutUserName!: string | undefined;
    capacityUnit!: string | undefined;
    price!: number;

    constructor(data?: INormalReagentStockListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.amount = data["amount"];
            this.realAmount = data["realAmount"];
            this.barCode = data["barCode"];
            this.batchNo = data["batchNo"];
            this.productionDate = data["productionDate"] ? new Date(data["productionDate"].toString()) : <any>undefined;
            this.expirationMonth = data["expirationMonth"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.locationId = data["locationId"];
            this.locationName = data["locationName"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.supplierCompanyId = data["supplierCompanyId"];
            this.supplierCompanyName = data["supplierCompanyName"];
            this.productionCompanyId = data["productionCompanyId"];
            this.productionCompanyName = data["productionCompanyName"];
            this.stockStatus = data["stockStatus"];
            this.reagentId = data["reagentId"];
            this.reagentCasNo = data["reagentCasNo"];
            this.reagentNo = data["reagentNo"];
            this.reagentCnName = data["reagentCnName"];
            this.reagentCnAliasName = data["reagentCnAliasName"];
            this.reagentEnName = data["reagentEnName"];
            this.reagentPurity = data["reagentPurity"];
            this.pinYinCode = data["pinYinCode"];
            this.casNo = data["casNo"];
            this.createUserName = data["createUserName"];
            this.capacity = data["capacity"];
            this.stockInTime = data["stockInTime"] ? new Date(data["stockInTime"].toString()) : <any>undefined;
            this.latestStockInTime = data["latestStockInTime"] ? new Date(data["latestStockInTime"].toString()) : <any>undefined;
            this.latestStockInUserName = data["latestStockInUserName"];
            this.latestStockOutTime = data["latestStockOutTime"] ? new Date(data["latestStockOutTime"].toString()) : <any>undefined;
            this.latestStockOutUserName = data["latestStockOutUserName"];
            this.capacityUnit = data["capacityUnit"];
            this.price = data["price"];
        }
    }

    static fromJS(data: any): NormalReagentStockListDto {
        data = typeof data === 'object' ? data : {};
        let result = new NormalReagentStockListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["amount"] = this.amount;
        data["realAmount"] = this.realAmount;
        data["barCode"] = this.barCode;
        data["batchNo"] = this.batchNo;
        data["productionDate"] = this.productionDate ? this.productionDate.toISOString() : <any>undefined;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["supplierCompanyId"] = this.supplierCompanyId;
        data["supplierCompanyName"] = this.supplierCompanyName;
        data["productionCompanyId"] = this.productionCompanyId;
        data["productionCompanyName"] = this.productionCompanyName;
        data["stockStatus"] = this.stockStatus;
        data["reagentId"] = this.reagentId;
        data["reagentCasNo"] = this.reagentCasNo;
        data["reagentNo"] = this.reagentNo;
        data["reagentCnName"] = this.reagentCnName;
        data["reagentCnAliasName"] = this.reagentCnAliasName;
        data["reagentEnName"] = this.reagentEnName;
        data["reagentPurity"] = this.reagentPurity;
        data["pinYinCode"] = this.pinYinCode;
        data["casNo"] = this.casNo;
        data["createUserName"] = this.createUserName;
        data["capacity"] = this.capacity;
        data["stockInTime"] = this.stockInTime ? this.stockInTime.toISOString() : <any>undefined;
        data["latestStockInTime"] = this.latestStockInTime ? this.latestStockInTime.toISOString() : <any>undefined;
        data["latestStockInUserName"] = this.latestStockInUserName;
        data["latestStockOutTime"] = this.latestStockOutTime ? this.latestStockOutTime.toISOString() : <any>undefined;
        data["latestStockOutUserName"] = this.latestStockOutUserName;
        data["capacityUnit"] = this.capacityUnit;
        data["price"] = this.price;
        return data; 
    }

    clone(): NormalReagentStockListDto {
        const json = this.toJSON();
        let result = new NormalReagentStockListDto();
        result.init(json);
        return result;
    }
}

export interface INormalReagentStockListDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    amount: number;
    realAmount: number;
    barCode: string | undefined;
    batchNo: string | undefined;
    productionDate: Date | undefined;
    expirationMonth: number;
    expirationDate: Date;
    locationId: number;
    locationName: string | undefined;
    warehouseId: number;
    warehouseName: string | undefined;
    supplierCompanyId: number | undefined;
    supplierCompanyName: string | undefined;
    productionCompanyId: number | undefined;
    productionCompanyName: string | undefined;
    stockStatus: ReagentStockStatusEnum;
    reagentId: number;
    reagentCasNo: string | undefined;
    reagentNo: string | undefined;
    reagentCnName: string | undefined;
    reagentCnAliasName: string | undefined;
    reagentEnName: string | undefined;
    reagentPurity: string | undefined;
    pinYinCode: string | undefined;
    casNo: string | undefined;
    createUserName: string | undefined;
    capacity: string | undefined;
    stockInTime: Date | undefined;
    latestStockInTime: Date | undefined;
    latestStockInUserName: string | undefined;
    latestStockOutTime: Date | undefined;
    latestStockOutUserName: string | undefined;
    capacityUnit: string | undefined;
    price: number;
}

export class NormalReagentStockListDtoPagedResultDto implements INormalReagentStockListDtoPagedResultDto {
    items!: NormalReagentStockListDto[] | undefined;
    totalCount!: number;

    constructor(data?: INormalReagentStockListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NormalReagentStockListDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): NormalReagentStockListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NormalReagentStockListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): NormalReagentStockListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NormalReagentStockListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INormalReagentStockListDtoPagedResultDto {
    items: NormalReagentStockListDto[] | undefined;
    totalCount: number;
}

export class NotificationData implements INotificationData {
    type!: string | undefined;
    properties!: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }

    clone(): NotificationData {
        const json = this.toJSON();
        let result = new NotificationData();
        result.init(json);
        return result;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0, 
    Success = 1, 
    Warn = 2, 
    Error = 3, 
    Fatal = 4, 
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    name!: string;
    isSubscribed!: boolean;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): NotificationSubscriptionWithDisplayNameDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    name: string;
    isSubscribed: boolean;
    displayName: string | undefined;
    description: string | undefined;
}

export enum OperateTypeEnum {
    入库 = 1, 
    领用 = 2, 
    归还 = 3, 
    回收 = 4, 
}

export class OrderConfirmEdInputDto implements IOrderConfirmEdInputDto {
    orderItemId!: number;
    auditResult!: OutOrderMasterItemStatues;

    constructor(data?: IOrderConfirmEdInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderItemId = data["orderItemId"];
            this.auditResult = data["auditResult"];
        }
    }

    static fromJS(data: any): OrderConfirmEdInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderConfirmEdInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemId"] = this.orderItemId;
        data["auditResult"] = this.auditResult;
        return data; 
    }

    clone(): OrderConfirmEdInputDto {
        const json = this.toJSON();
        let result = new OrderConfirmEdInputDto();
        result.init(json);
        return result;
    }
}

export interface IOrderConfirmEdInputDto {
    orderItemId: number;
    auditResult: OutOrderMasterItemStatues;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    lastModificationTime!: Date | undefined;
    lastModifierUserId!: number | undefined;
    sort!: number;
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.sort = data["sort"];
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["sort"] = this.sort;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        return data; 
    }

    clone(): OrganizationUnitDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    sort: number;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
}

export class OrganizationUnitDtoListResultDto implements IOrganizationUnitDtoListResultDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IOrganizationUnitDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrganizationUnitDtoListResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: Date;
    isOnline!: boolean;
    avatar!: number | undefined;
    avatarUrl!: string | undefined;
    phoneNumber!: string | undefined;
    isOrgMaster!: boolean;
    orgMasterCode!: string | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? new Date(data["addedTime"].toString()) : <any>undefined;
            this.isOnline = data["isOnline"];
            this.avatar = data["avatar"];
            this.avatarUrl = data["avatarUrl"];
            this.phoneNumber = data["phoneNumber"];
            this.isOrgMaster = data["isOrgMaster"];
            this.orgMasterCode = data["orgMasterCode"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["isOnline"] = this.isOnline;
        data["avatar"] = this.avatar;
        data["avatarUrl"] = this.avatarUrl;
        data["phoneNumber"] = this.phoneNumber;
        data["isOrgMaster"] = this.isOrgMaster;
        data["orgMasterCode"] = this.orgMasterCode;
        return data; 
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: Date;
    isOnline: boolean;
    avatar: number | undefined;
    avatarUrl: string | undefined;
    phoneNumber: string | undefined;
    isOrgMaster: boolean;
    orgMasterCode: string | undefined;
}

export class OrganizationUnitUserListDtoPagedResultDto implements IOrganizationUnitUserListDtoPagedResultDto {
    items!: OrganizationUnitUserListDto[] | undefined;
    totalCount!: number;

    constructor(data?: IOrganizationUnitUserListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): OrganizationUnitUserListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDtoPagedResultDto {
    items: OrganizationUnitUserListDto[] | undefined;
    totalCount: number;
}

export class OutOrderDto implements IOutOrderDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    isReleased!: boolean;
    outOrderStatus!: OutOrderStatusEnum;
    warehouseId!: number;
    warehouseName!: string | undefined;
    outOrderType!: OutOrderTypeEnum;
    applyUserId!: number | undefined;
    applyUserName!: string | undefined;
    applyUserUserName!: string | undefined;
    outOrderMasterItems!: OutOrderMasterItemDto[] | undefined;

    constructor(data?: IOutOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.isReleased = data["isReleased"];
            this.outOrderStatus = data["outOrderStatus"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.outOrderType = data["outOrderType"];
            this.applyUserId = data["applyUserId"];
            this.applyUserName = data["applyUserName"];
            this.applyUserUserName = data["applyUserUserName"];
            if (data["outOrderMasterItems"] && data["outOrderMasterItems"].constructor === Array) {
                this.outOrderMasterItems = [];
                for (let item of data["outOrderMasterItems"])
                    this.outOrderMasterItems.push(OutOrderMasterItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["isReleased"] = this.isReleased;
        data["outOrderStatus"] = this.outOrderStatus;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["outOrderType"] = this.outOrderType;
        data["applyUserId"] = this.applyUserId;
        data["applyUserName"] = this.applyUserName;
        data["applyUserUserName"] = this.applyUserUserName;
        if (this.outOrderMasterItems && this.outOrderMasterItems.constructor === Array) {
            data["outOrderMasterItems"] = [];
            for (let item of this.outOrderMasterItems)
                data["outOrderMasterItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OutOrderDto {
        const json = this.toJSON();
        let result = new OutOrderDto();
        result.init(json);
        return result;
    }
}

export interface IOutOrderDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    isReleased: boolean;
    outOrderStatus: OutOrderStatusEnum;
    warehouseId: number;
    warehouseName: string | undefined;
    outOrderType: OutOrderTypeEnum;
    applyUserId: number | undefined;
    applyUserName: string | undefined;
    applyUserUserName: string | undefined;
    outOrderMasterItems: OutOrderMasterItemDto[] | undefined;
}

export class OutOrderDtoPagedResultDto implements IOutOrderDtoPagedResultDto {
    items!: OutOrderDto[] | undefined;
    totalCount!: number;

    constructor(data?: IOutOrderDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OutOrderDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): OutOrderDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutOrderDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): OutOrderDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OutOrderDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOutOrderDtoPagedResultDto {
    items: OutOrderDto[] | undefined;
    totalCount: number;
}

export class OutOrderMasterItemAuditDto implements IOutOrderMasterItemAuditDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    outOrderMasterItemId!: number;
    reagentStockAuditType!: ReagentStockAuditTypeEnum;
    auditResult!: OutOrderMasterItemStatues;
    auditUserName!: string | undefined;
    auditUserId!: number;

    constructor(data?: IOutOrderMasterItemAuditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.outOrderMasterItemId = data["outOrderMasterItemId"];
            this.reagentStockAuditType = data["reagentStockAuditType"];
            this.auditResult = data["auditResult"];
            this.auditUserName = data["auditUserName"];
            this.auditUserId = data["auditUserId"];
        }
    }

    static fromJS(data: any): OutOrderMasterItemAuditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutOrderMasterItemAuditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["outOrderMasterItemId"] = this.outOrderMasterItemId;
        data["reagentStockAuditType"] = this.reagentStockAuditType;
        data["auditResult"] = this.auditResult;
        data["auditUserName"] = this.auditUserName;
        data["auditUserId"] = this.auditUserId;
        return data; 
    }

    clone(): OutOrderMasterItemAuditDto {
        const json = this.toJSON();
        let result = new OutOrderMasterItemAuditDto();
        result.init(json);
        return result;
    }
}

export interface IOutOrderMasterItemAuditDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    outOrderMasterItemId: number;
    reagentStockAuditType: ReagentStockAuditTypeEnum;
    auditResult: OutOrderMasterItemStatues;
    auditUserName: string | undefined;
    auditUserId: number;
}

export class OutOrderMasterItemDto implements IOutOrderMasterItemDto {
    id!: number;
    price!: number;
    stockOutTime!: Date | undefined;
    outOrderId!: number;
    clientConfirm!: boolean;
    doubleConfirm!: boolean;
    clientConfirmed!: OutOrderMasterItemStatues;
    doubleConfirmed!: OutOrderMasterItemStatues;
    reagentStockId!: number | undefined;
    reagentStockBarCode!: string | undefined;
    reagentStockBatchNo!: string | undefined;
    reagentStockCapacity!: string | undefined;
    reagentStockCapacityUnit!: string | undefined;
    reagentStockSafeAttribute!: SafeAttributes;
    stockoutAccount!: number;
    reagentId!: number | undefined;
    reagentPinYinCode!: string | undefined;
    reagentCasNo!: string | undefined;
    locationId!: number | undefined;
    reagentPurity!: string | undefined;
    locationName!: string | undefined;
    reagentNo!: string | undefined;
    reagentCnName!: string | undefined;
    reagentCnAliasName!: string | undefined;
    reagentEnName!: string | undefined;
    reagentReagentCatalog!: ReagentCatalog;

    constructor(data?: IOutOrderMasterItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.price = data["price"];
            this.stockOutTime = data["stockOutTime"] ? new Date(data["stockOutTime"].toString()) : <any>undefined;
            this.outOrderId = data["outOrderId"];
            this.clientConfirm = data["clientConfirm"];
            this.doubleConfirm = data["doubleConfirm"];
            this.clientConfirmed = data["clientConfirmed"];
            this.doubleConfirmed = data["doubleConfirmed"];
            this.reagentStockId = data["reagentStockId"];
            this.reagentStockBarCode = data["reagentStockBarCode"];
            this.reagentStockBatchNo = data["reagentStockBatchNo"];
            this.reagentStockCapacity = data["reagentStockCapacity"];
            this.reagentStockCapacityUnit = data["reagentStockCapacityUnit"];
            this.reagentStockSafeAttribute = data["reagentStockSafeAttribute"];
            this.stockoutAccount = data["stockoutAccount"];
            this.reagentId = data["reagentId"];
            this.reagentPinYinCode = data["reagentPinYinCode"];
            this.reagentCasNo = data["reagentCasNo"];
            this.locationId = data["locationId"];
            this.reagentPurity = data["reagentPurity"];
            this.locationName = data["locationName"];
            this.reagentNo = data["reagentNo"];
            this.reagentCnName = data["reagentCnName"];
            this.reagentCnAliasName = data["reagentCnAliasName"];
            this.reagentEnName = data["reagentEnName"];
            this.reagentReagentCatalog = data["reagentReagentCatalog"];
        }
    }

    static fromJS(data: any): OutOrderMasterItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutOrderMasterItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["stockOutTime"] = this.stockOutTime ? this.stockOutTime.toISOString() : <any>undefined;
        data["outOrderId"] = this.outOrderId;
        data["clientConfirm"] = this.clientConfirm;
        data["doubleConfirm"] = this.doubleConfirm;
        data["clientConfirmed"] = this.clientConfirmed;
        data["doubleConfirmed"] = this.doubleConfirmed;
        data["reagentStockId"] = this.reagentStockId;
        data["reagentStockBarCode"] = this.reagentStockBarCode;
        data["reagentStockBatchNo"] = this.reagentStockBatchNo;
        data["reagentStockCapacity"] = this.reagentStockCapacity;
        data["reagentStockCapacityUnit"] = this.reagentStockCapacityUnit;
        data["reagentStockSafeAttribute"] = this.reagentStockSafeAttribute;
        data["stockoutAccount"] = this.stockoutAccount;
        data["reagentId"] = this.reagentId;
        data["reagentPinYinCode"] = this.reagentPinYinCode;
        data["reagentCasNo"] = this.reagentCasNo;
        data["locationId"] = this.locationId;
        data["reagentPurity"] = this.reagentPurity;
        data["locationName"] = this.locationName;
        data["reagentNo"] = this.reagentNo;
        data["reagentCnName"] = this.reagentCnName;
        data["reagentCnAliasName"] = this.reagentCnAliasName;
        data["reagentEnName"] = this.reagentEnName;
        data["reagentReagentCatalog"] = this.reagentReagentCatalog;
        return data; 
    }

    clone(): OutOrderMasterItemDto {
        const json = this.toJSON();
        let result = new OutOrderMasterItemDto();
        result.init(json);
        return result;
    }
}

export interface IOutOrderMasterItemDto {
    id: number;
    price: number;
    stockOutTime: Date | undefined;
    outOrderId: number;
    clientConfirm: boolean;
    doubleConfirm: boolean;
    clientConfirmed: OutOrderMasterItemStatues;
    doubleConfirmed: OutOrderMasterItemStatues;
    reagentStockId: number | undefined;
    reagentStockBarCode: string | undefined;
    reagentStockBatchNo: string | undefined;
    reagentStockCapacity: string | undefined;
    reagentStockCapacityUnit: string | undefined;
    reagentStockSafeAttribute: SafeAttributes;
    stockoutAccount: number;
    reagentId: number | undefined;
    reagentPinYinCode: string | undefined;
    reagentCasNo: string | undefined;
    locationId: number | undefined;
    reagentPurity: string | undefined;
    locationName: string | undefined;
    reagentNo: string | undefined;
    reagentCnName: string | undefined;
    reagentCnAliasName: string | undefined;
    reagentEnName: string | undefined;
    reagentReagentCatalog: ReagentCatalog;
}

export enum OutOrderMasterItemStatues {
    待审核 = 0, 
    审核通过 = 1, 
    审核不通过 = 2, 
}

export enum OutOrderStatusEnum {
    待出库 = 0, 
    出库完毕 = 1, 
    取消 = 2, 
}

export class OutOrderStockOutInputDto implements IOutOrderStockOutInputDto {
    orderId!: number;
    warehouseId!: number;
    items!: OutOrderStockOutInputItem[] | undefined;

    constructor(data?: IOutOrderStockOutInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.warehouseId = data["warehouseId"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OutOrderStockOutInputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutOrderStockOutInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutOrderStockOutInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["warehouseId"] = this.warehouseId;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OutOrderStockOutInputDto {
        const json = this.toJSON();
        let result = new OutOrderStockOutInputDto();
        result.init(json);
        return result;
    }
}

export interface IOutOrderStockOutInputDto {
    orderId: number;
    warehouseId: number;
    items: OutOrderStockOutInputItem[] | undefined;
}

export class OutOrderStockOutInputItem implements IOutOrderStockOutInputItem {
    barCode!: string;
    account!: number;

    constructor(data?: IOutOrderStockOutInputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.barCode = data["barCode"];
            this.account = data["account"];
        }
    }

    static fromJS(data: any): OutOrderStockOutInputItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutOrderStockOutInputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barCode"] = this.barCode;
        data["account"] = this.account;
        return data; 
    }

    clone(): OutOrderStockOutInputItem {
        const json = this.toJSON();
        let result = new OutOrderStockOutInputItem();
        result.init(json);
        return result;
    }
}

export interface IOutOrderStockOutInputItem {
    barCode: string;
    account: number;
}

export enum OutOrderTypeEnum {
    专管试剂 = 1, 
    普通试剂 = 2, 
}

export class PagedResultRequestFilterDto implements IPagedResultRequestFilterDto {
    filter!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagedResultRequestFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagedResultRequestFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultRequestFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): PagedResultRequestFilterDto {
        const json = this.toJSON();
        let result = new PagedResultRequestFilterDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultRequestFilterDto {
    filter: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class PermissionDto implements IPermissionDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items!: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export enum ReagentCatalog {
    常规试剂 = 0, 
    标品试剂 = 1, 
    专管试剂 = 2, 
}

export class ReagentDto implements IReagentDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    clientConfirmed!: boolean;
    doubleConfirmed!: boolean;
    clientConfirm!: boolean;
    doubleConfirm!: boolean;
    no!: string;
    reagentCatalog!: ReagentCatalog;
    casNo!: string | undefined;
    reagentStatus!: ReagentStatus;
    cnName!: string;
    cnAliasName!: string | undefined;
    enName!: string | undefined;
    safeAttribute!: SafeAttributes;
    storageAttr!: StorageAttrEnum;
    pinYinCode!: string | undefined;
    purity!: string | undefined;
    capacity!: string | undefined;
    capacityUnit!: string | undefined;
    storageCondition!: string | undefined;
    inventoryWarning!: number;
    supplierCompanyId!: number | undefined;
    supplierCompanyName!: string | undefined;
    productionCompanyId!: number | undefined;
    productionCompanyName!: string | undefined;
    reagentLocations!: ReagentLocationDto[] | undefined;
    reagentLocationIds!: number[] | undefined;
    createUserName!: string | undefined;
    price!: number;

    constructor(data?: IReagentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.clientConfirmed = data["clientConfirmed"];
            this.doubleConfirmed = data["doubleConfirmed"];
            this.clientConfirm = data["clientConfirm"];
            this.doubleConfirm = data["doubleConfirm"];
            this.no = data["no"];
            this.reagentCatalog = data["reagentCatalog"];
            this.casNo = data["casNo"];
            this.reagentStatus = data["reagentStatus"];
            this.cnName = data["cnName"];
            this.cnAliasName = data["cnAliasName"];
            this.enName = data["enName"];
            this.safeAttribute = data["safeAttribute"];
            this.storageAttr = data["storageAttr"];
            this.pinYinCode = data["pinYinCode"];
            this.purity = data["purity"];
            this.capacity = data["capacity"];
            this.capacityUnit = data["capacityUnit"];
            this.storageCondition = data["storageCondition"];
            this.inventoryWarning = data["inventoryWarning"];
            this.supplierCompanyId = data["supplierCompanyId"];
            this.supplierCompanyName = data["supplierCompanyName"];
            this.productionCompanyId = data["productionCompanyId"];
            this.productionCompanyName = data["productionCompanyName"];
            if (data["reagentLocations"] && data["reagentLocations"].constructor === Array) {
                this.reagentLocations = [];
                for (let item of data["reagentLocations"])
                    this.reagentLocations.push(ReagentLocationDto.fromJS(item));
            }
            if (data["reagentLocationIds"] && data["reagentLocationIds"].constructor === Array) {
                this.reagentLocationIds = [];
                for (let item of data["reagentLocationIds"])
                    this.reagentLocationIds.push(item);
            }
            this.createUserName = data["createUserName"];
            this.price = data["price"];
        }
    }

    static fromJS(data: any): ReagentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["clientConfirmed"] = this.clientConfirmed;
        data["doubleConfirmed"] = this.doubleConfirmed;
        data["clientConfirm"] = this.clientConfirm;
        data["doubleConfirm"] = this.doubleConfirm;
        data["no"] = this.no;
        data["reagentCatalog"] = this.reagentCatalog;
        data["casNo"] = this.casNo;
        data["reagentStatus"] = this.reagentStatus;
        data["cnName"] = this.cnName;
        data["cnAliasName"] = this.cnAliasName;
        data["enName"] = this.enName;
        data["safeAttribute"] = this.safeAttribute;
        data["storageAttr"] = this.storageAttr;
        data["pinYinCode"] = this.pinYinCode;
        data["purity"] = this.purity;
        data["capacity"] = this.capacity;
        data["capacityUnit"] = this.capacityUnit;
        data["storageCondition"] = this.storageCondition;
        data["inventoryWarning"] = this.inventoryWarning;
        data["supplierCompanyId"] = this.supplierCompanyId;
        data["supplierCompanyName"] = this.supplierCompanyName;
        data["productionCompanyId"] = this.productionCompanyId;
        data["productionCompanyName"] = this.productionCompanyName;
        if (this.reagentLocations && this.reagentLocations.constructor === Array) {
            data["reagentLocations"] = [];
            for (let item of this.reagentLocations)
                data["reagentLocations"].push(item.toJSON());
        }
        if (this.reagentLocationIds && this.reagentLocationIds.constructor === Array) {
            data["reagentLocationIds"] = [];
            for (let item of this.reagentLocationIds)
                data["reagentLocationIds"].push(item);
        }
        data["createUserName"] = this.createUserName;
        data["price"] = this.price;
        return data; 
    }

    clone(): ReagentDto {
        const json = this.toJSON();
        let result = new ReagentDto();
        result.init(json);
        return result;
    }
}

export interface IReagentDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    clientConfirmed: boolean;
    doubleConfirmed: boolean;
    clientConfirm: boolean;
    doubleConfirm: boolean;
    no: string;
    reagentCatalog: ReagentCatalog;
    casNo: string | undefined;
    reagentStatus: ReagentStatus;
    cnName: string;
    cnAliasName: string | undefined;
    enName: string | undefined;
    safeAttribute: SafeAttributes;
    storageAttr: StorageAttrEnum;
    pinYinCode: string | undefined;
    purity: string | undefined;
    capacity: string | undefined;
    capacityUnit: string | undefined;
    storageCondition: string | undefined;
    inventoryWarning: number;
    supplierCompanyId: number | undefined;
    supplierCompanyName: string | undefined;
    productionCompanyId: number | undefined;
    productionCompanyName: string | undefined;
    reagentLocations: ReagentLocationDto[] | undefined;
    reagentLocationIds: number[] | undefined;
    createUserName: string | undefined;
    price: number;
}

export class ReagentDtoPagedResultDto implements IReagentDtoPagedResultDto {
    items!: ReagentDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReagentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ReagentDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): ReagentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ReagentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReagentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReagentDtoPagedResultDto {
    items: ReagentDto[] | undefined;
    totalCount: number;
}

export class ReagentLocationDto implements IReagentLocationDto {
    id!: number;
    reagentId!: number;
    locationId!: number;
    locationWarehouseId!: number;
    locationName!: string | undefined;

    constructor(data?: IReagentLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.reagentId = data["reagentId"];
            this.locationId = data["locationId"];
            this.locationWarehouseId = data["locationWarehouseId"];
            this.locationName = data["locationName"];
        }
    }

    static fromJS(data: any): ReagentLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reagentId"] = this.reagentId;
        data["locationId"] = this.locationId;
        data["locationWarehouseId"] = this.locationWarehouseId;
        data["locationName"] = this.locationName;
        return data; 
    }

    clone(): ReagentLocationDto {
        const json = this.toJSON();
        let result = new ReagentLocationDto();
        result.init(json);
        return result;
    }
}

export interface IReagentLocationDto {
    id: number;
    reagentId: number;
    locationId: number;
    locationWarehouseId: number;
    locationName: string | undefined;
}

export class ReagentOperateRecordDto implements IReagentOperateRecordDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    weight!: number;
    operateAmount!: number;
    normalReagentStockId!: number;
    barCode!: string | undefined;
    locationId!: number;
    locationName!: string | undefined;
    warehouseId!: number;
    warehouseName!: string | undefined;
    capacity!: string | undefined;
    capacityUnit!: string | undefined;
    batchNo!: string | undefined;
    safeAttribute!: SafeAttributes;
    operateType!: OperateTypeEnum;
    reagentId!: number;
    reagentCasNo!: string | undefined;
    reagentNo!: string | undefined;
    reagentCnName!: string | undefined;
    reagentCnAliasName!: string | undefined;
    reagentEnName!: string | undefined;
    createUserName!: string | undefined;
    year!: number;
    month!: number;
    day!: number;
    hour!: number;
    minute!: number;

    constructor(data?: IReagentOperateRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.weight = data["weight"];
            this.operateAmount = data["operateAmount"];
            this.normalReagentStockId = data["normalReagentStockId"];
            this.barCode = data["barCode"];
            this.locationId = data["locationId"];
            this.locationName = data["locationName"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.capacity = data["capacity"];
            this.capacityUnit = data["capacityUnit"];
            this.batchNo = data["batchNo"];
            this.safeAttribute = data["safeAttribute"];
            this.operateType = data["operateType"];
            this.reagentId = data["reagentId"];
            this.reagentCasNo = data["reagentCasNo"];
            this.reagentNo = data["reagentNo"];
            this.reagentCnName = data["reagentCnName"];
            this.reagentCnAliasName = data["reagentCnAliasName"];
            this.reagentEnName = data["reagentEnName"];
            this.createUserName = data["createUserName"];
            this.year = data["year"];
            this.month = data["month"];
            this.day = data["day"];
            this.hour = data["hour"];
            this.minute = data["minute"];
        }
    }

    static fromJS(data: any): ReagentOperateRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentOperateRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["weight"] = this.weight;
        data["operateAmount"] = this.operateAmount;
        data["normalReagentStockId"] = this.normalReagentStockId;
        data["barCode"] = this.barCode;
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["capacity"] = this.capacity;
        data["capacityUnit"] = this.capacityUnit;
        data["batchNo"] = this.batchNo;
        data["safeAttribute"] = this.safeAttribute;
        data["operateType"] = this.operateType;
        data["reagentId"] = this.reagentId;
        data["reagentCasNo"] = this.reagentCasNo;
        data["reagentNo"] = this.reagentNo;
        data["reagentCnName"] = this.reagentCnName;
        data["reagentCnAliasName"] = this.reagentCnAliasName;
        data["reagentEnName"] = this.reagentEnName;
        data["createUserName"] = this.createUserName;
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        return data; 
    }

    clone(): ReagentOperateRecordDto {
        const json = this.toJSON();
        let result = new ReagentOperateRecordDto();
        result.init(json);
        return result;
    }
}

export interface IReagentOperateRecordDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    weight: number;
    operateAmount: number;
    normalReagentStockId: number;
    barCode: string | undefined;
    locationId: number;
    locationName: string | undefined;
    warehouseId: number;
    warehouseName: string | undefined;
    capacity: string | undefined;
    capacityUnit: string | undefined;
    batchNo: string | undefined;
    safeAttribute: SafeAttributes;
    operateType: OperateTypeEnum;
    reagentId: number;
    reagentCasNo: string | undefined;
    reagentNo: string | undefined;
    reagentCnName: string | undefined;
    reagentCnAliasName: string | undefined;
    reagentEnName: string | undefined;
    createUserName: string | undefined;
    year: number;
    month: number;
    day: number;
    hour: number;
    minute: number;
}

export class ReagentOperateRecordDtoPagedResultDto implements IReagentOperateRecordDtoPagedResultDto {
    items!: ReagentOperateRecordDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReagentOperateRecordDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ReagentOperateRecordDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): ReagentOperateRecordDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentOperateRecordDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ReagentOperateRecordDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReagentOperateRecordDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReagentOperateRecordDtoPagedResultDto {
    items: ReagentOperateRecordDto[] | undefined;
    totalCount: number;
}

export enum ReagentStatus {
    液体 = 0, 
    固体 = 1, 
    气体 = 2, 
}

export class ReagentStockAuditDto implements IReagentStockAuditDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    reagentStockId!: number;
    reagentStockAuditType!: ReagentStockAuditTypeEnum;
    auditUserName!: string | undefined;
    auditUserId!: number;

    constructor(data?: IReagentStockAuditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.reagentStockId = data["reagentStockId"];
            this.reagentStockAuditType = data["reagentStockAuditType"];
            this.auditUserName = data["auditUserName"];
            this.auditUserId = data["auditUserId"];
        }
    }

    static fromJS(data: any): ReagentStockAuditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentStockAuditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["reagentStockId"] = this.reagentStockId;
        data["reagentStockAuditType"] = this.reagentStockAuditType;
        data["auditUserName"] = this.auditUserName;
        data["auditUserId"] = this.auditUserId;
        return data; 
    }

    clone(): ReagentStockAuditDto {
        const json = this.toJSON();
        let result = new ReagentStockAuditDto();
        result.init(json);
        return result;
    }
}

export interface IReagentStockAuditDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    reagentStockId: number;
    reagentStockAuditType: ReagentStockAuditTypeEnum;
    auditUserName: string | undefined;
    auditUserId: number;
}

export enum ReagentStockAuditTypeEnum {
    入库确认 = 1, 
    入库双人双锁 = 2, 
    出库确认 = 3, 
    出库双人双锁 = 4, 
}

export class ReagentStockDto implements IReagentStockDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    weight!: number;
    price!: number;
    isMaster!: boolean;
    barCode!: string | undefined;
    batchNo!: string | undefined;
    productionDate!: Date | undefined;
    expirationMonth!: number;
    expirationDate!: Date;
    locationId!: number;
    locationName!: string | undefined;
    warehouseId!: number;
    warehouseName!: string | undefined;
    capacity!: string | undefined;
    capacityUnit!: string | undefined;
    supplierCompanyId!: number | undefined;
    supplierCompanyName!: string | undefined;
    productionCompanyId!: number | undefined;
    productionCompanyName!: string | undefined;
    stockStatus!: ReagentStockStatusEnum;
    firstStockInTime!: Date | undefined;
    latestStockInTime!: Date | undefined;
    latestStockInUserName!: string | undefined;
    latestStockOutTime!: Date | undefined;
    latestStockOutUserName!: string | undefined;
    retrieveTime!: Date | undefined;
    retrieveUserName!: string | undefined;
    reagentId!: number;
    reagentCasNo!: string | undefined;
    reagentNo!: string | undefined;
    reagentCnName!: string | undefined;
    reagentCnAliasName!: string | undefined;
    reagentEnName!: string | undefined;
    reagentPurity!: string | undefined;
    clientConfirm!: boolean;
    doubleConfirm!: boolean;
    reagentSafeAttribute!: SafeAttributes;
    isDeleted!: boolean;
    createUserName!: string | undefined;
    amount!: number;
    realAmount!: number;

    constructor(data?: IReagentStockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.weight = data["weight"];
            this.price = data["price"];
            this.isMaster = data["isMaster"];
            this.barCode = data["barCode"];
            this.batchNo = data["batchNo"];
            this.productionDate = data["productionDate"] ? new Date(data["productionDate"].toString()) : <any>undefined;
            this.expirationMonth = data["expirationMonth"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.locationId = data["locationId"];
            this.locationName = data["locationName"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.capacity = data["capacity"];
            this.capacityUnit = data["capacityUnit"];
            this.supplierCompanyId = data["supplierCompanyId"];
            this.supplierCompanyName = data["supplierCompanyName"];
            this.productionCompanyId = data["productionCompanyId"];
            this.productionCompanyName = data["productionCompanyName"];
            this.stockStatus = data["stockStatus"];
            this.firstStockInTime = data["firstStockInTime"] ? new Date(data["firstStockInTime"].toString()) : <any>undefined;
            this.latestStockInTime = data["latestStockInTime"] ? new Date(data["latestStockInTime"].toString()) : <any>undefined;
            this.latestStockInUserName = data["latestStockInUserName"];
            this.latestStockOutTime = data["latestStockOutTime"] ? new Date(data["latestStockOutTime"].toString()) : <any>undefined;
            this.latestStockOutUserName = data["latestStockOutUserName"];
            this.retrieveTime = data["retrieveTime"] ? new Date(data["retrieveTime"].toString()) : <any>undefined;
            this.retrieveUserName = data["retrieveUserName"];
            this.reagentId = data["reagentId"];
            this.reagentCasNo = data["reagentCasNo"];
            this.reagentNo = data["reagentNo"];
            this.reagentCnName = data["reagentCnName"];
            this.reagentCnAliasName = data["reagentCnAliasName"];
            this.reagentEnName = data["reagentEnName"];
            this.reagentPurity = data["reagentPurity"];
            this.clientConfirm = data["clientConfirm"];
            this.doubleConfirm = data["doubleConfirm"];
            this.reagentSafeAttribute = data["reagentSafeAttribute"];
            this.isDeleted = data["isDeleted"];
            this.createUserName = data["createUserName"];
            this.amount = data["amount"];
            this.realAmount = data["realAmount"];
        }
    }

    static fromJS(data: any): ReagentStockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentStockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["weight"] = this.weight;
        data["price"] = this.price;
        data["isMaster"] = this.isMaster;
        data["barCode"] = this.barCode;
        data["batchNo"] = this.batchNo;
        data["productionDate"] = this.productionDate ? this.productionDate.toISOString() : <any>undefined;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["locationId"] = this.locationId;
        data["locationName"] = this.locationName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["capacity"] = this.capacity;
        data["capacityUnit"] = this.capacityUnit;
        data["supplierCompanyId"] = this.supplierCompanyId;
        data["supplierCompanyName"] = this.supplierCompanyName;
        data["productionCompanyId"] = this.productionCompanyId;
        data["productionCompanyName"] = this.productionCompanyName;
        data["stockStatus"] = this.stockStatus;
        data["firstStockInTime"] = this.firstStockInTime ? this.firstStockInTime.toISOString() : <any>undefined;
        data["latestStockInTime"] = this.latestStockInTime ? this.latestStockInTime.toISOString() : <any>undefined;
        data["latestStockInUserName"] = this.latestStockInUserName;
        data["latestStockOutTime"] = this.latestStockOutTime ? this.latestStockOutTime.toISOString() : <any>undefined;
        data["latestStockOutUserName"] = this.latestStockOutUserName;
        data["retrieveTime"] = this.retrieveTime ? this.retrieveTime.toISOString() : <any>undefined;
        data["retrieveUserName"] = this.retrieveUserName;
        data["reagentId"] = this.reagentId;
        data["reagentCasNo"] = this.reagentCasNo;
        data["reagentNo"] = this.reagentNo;
        data["reagentCnName"] = this.reagentCnName;
        data["reagentCnAliasName"] = this.reagentCnAliasName;
        data["reagentEnName"] = this.reagentEnName;
        data["reagentPurity"] = this.reagentPurity;
        data["clientConfirm"] = this.clientConfirm;
        data["doubleConfirm"] = this.doubleConfirm;
        data["reagentSafeAttribute"] = this.reagentSafeAttribute;
        data["isDeleted"] = this.isDeleted;
        data["createUserName"] = this.createUserName;
        data["amount"] = this.amount;
        data["realAmount"] = this.realAmount;
        return data; 
    }

    clone(): ReagentStockDto {
        const json = this.toJSON();
        let result = new ReagentStockDto();
        result.init(json);
        return result;
    }
}

export interface IReagentStockDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    weight: number;
    price: number;
    isMaster: boolean;
    barCode: string | undefined;
    batchNo: string | undefined;
    productionDate: Date | undefined;
    expirationMonth: number;
    expirationDate: Date;
    locationId: number;
    locationName: string | undefined;
    warehouseId: number;
    warehouseName: string | undefined;
    capacity: string | undefined;
    capacityUnit: string | undefined;
    supplierCompanyId: number | undefined;
    supplierCompanyName: string | undefined;
    productionCompanyId: number | undefined;
    productionCompanyName: string | undefined;
    stockStatus: ReagentStockStatusEnum;
    firstStockInTime: Date | undefined;
    latestStockInTime: Date | undefined;
    latestStockInUserName: string | undefined;
    latestStockOutTime: Date | undefined;
    latestStockOutUserName: string | undefined;
    retrieveTime: Date | undefined;
    retrieveUserName: string | undefined;
    reagentId: number;
    reagentCasNo: string | undefined;
    reagentNo: string | undefined;
    reagentCnName: string | undefined;
    reagentCnAliasName: string | undefined;
    reagentEnName: string | undefined;
    reagentPurity: string | undefined;
    clientConfirm: boolean;
    doubleConfirm: boolean;
    reagentSafeAttribute: SafeAttributes;
    isDeleted: boolean;
    createUserName: string | undefined;
    amount: number;
    realAmount: number;
}

export class ReagentStockDtoPagedResultDto implements IReagentStockDtoPagedResultDto {
    items!: ReagentStockDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReagentStockDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ReagentStockDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): ReagentStockDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentStockDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ReagentStockDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReagentStockDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReagentStockDtoPagedResultDto {
    items: ReagentStockDto[] | undefined;
    totalCount: number;
}

export class ReagentStockListDto implements IReagentStockListDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    weight!: number;
    lockedOrderId!: number | undefined;
    clientConfirm!: boolean;
    doubleConfirm!: boolean;
    clientConfirmed!: boolean;
    doubleConfirmed!: boolean;
    barCode!: string | undefined;
    batchNo!: string | undefined;
    casNo!: string | undefined;
    productionDate!: Date | undefined;
    expirationMonth!: number;
    expirationDate!: Date;
    locationName!: string | undefined;
    warehouseId!: number;
    warehouseName!: string | undefined;
    capacity!: string | undefined;
    capacityUnit!: string | undefined;
    supplierCompanyId!: number | undefined;
    supplierCompanyName!: string | undefined;
    productionCompanyId!: number | undefined;
    productionCompanyName!: string | undefined;
    stockStatus!: ReagentStockStatusEnum;
    firstStockInTime!: Date | undefined;
    latestStockInTime!: Date | undefined;
    latestStockInUserName!: string | undefined;
    latestStockOutTime!: Date | undefined;
    latestStockOutUserName!: string | undefined;
    retrieveTime!: Date | undefined;
    retrieveUserName!: string | undefined;
    reagentId!: number;
    reagentCasNo!: string | undefined;
    reagentNo!: string | undefined;
    reagentCnName!: string | undefined;
    reagentCnAliasName!: string | undefined;
    reagentEnName!: string | undefined;
    reagentSafeAttribute!: SafeAttributes;
    reagentStorageAttr!: StorageAttrEnum;
    reagentPurity!: string | undefined;
    isDeleted!: boolean;
    createUserName!: string | undefined;
    price!: number;

    constructor(data?: IReagentStockListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.weight = data["weight"];
            this.lockedOrderId = data["lockedOrderId"];
            this.clientConfirm = data["clientConfirm"];
            this.doubleConfirm = data["doubleConfirm"];
            this.clientConfirmed = data["clientConfirmed"];
            this.doubleConfirmed = data["doubleConfirmed"];
            this.barCode = data["barCode"];
            this.batchNo = data["batchNo"];
            this.casNo = data["casNo"];
            this.productionDate = data["productionDate"] ? new Date(data["productionDate"].toString()) : <any>undefined;
            this.expirationMonth = data["expirationMonth"];
            this.expirationDate = data["expirationDate"] ? new Date(data["expirationDate"].toString()) : <any>undefined;
            this.locationName = data["locationName"];
            this.warehouseId = data["warehouseId"];
            this.warehouseName = data["warehouseName"];
            this.capacity = data["capacity"];
            this.capacityUnit = data["capacityUnit"];
            this.supplierCompanyId = data["supplierCompanyId"];
            this.supplierCompanyName = data["supplierCompanyName"];
            this.productionCompanyId = data["productionCompanyId"];
            this.productionCompanyName = data["productionCompanyName"];
            this.stockStatus = data["stockStatus"];
            this.firstStockInTime = data["firstStockInTime"] ? new Date(data["firstStockInTime"].toString()) : <any>undefined;
            this.latestStockInTime = data["latestStockInTime"] ? new Date(data["latestStockInTime"].toString()) : <any>undefined;
            this.latestStockInUserName = data["latestStockInUserName"];
            this.latestStockOutTime = data["latestStockOutTime"] ? new Date(data["latestStockOutTime"].toString()) : <any>undefined;
            this.latestStockOutUserName = data["latestStockOutUserName"];
            this.retrieveTime = data["retrieveTime"] ? new Date(data["retrieveTime"].toString()) : <any>undefined;
            this.retrieveUserName = data["retrieveUserName"];
            this.reagentId = data["reagentId"];
            this.reagentCasNo = data["reagentCasNo"];
            this.reagentNo = data["reagentNo"];
            this.reagentCnName = data["reagentCnName"];
            this.reagentCnAliasName = data["reagentCnAliasName"];
            this.reagentEnName = data["reagentEnName"];
            this.reagentSafeAttribute = data["reagentSafeAttribute"];
            this.reagentStorageAttr = data["reagentStorageAttr"];
            this.reagentPurity = data["reagentPurity"];
            this.isDeleted = data["isDeleted"];
            this.createUserName = data["createUserName"];
            this.price = data["price"];
        }
    }

    static fromJS(data: any): ReagentStockListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentStockListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["weight"] = this.weight;
        data["lockedOrderId"] = this.lockedOrderId;
        data["clientConfirm"] = this.clientConfirm;
        data["doubleConfirm"] = this.doubleConfirm;
        data["clientConfirmed"] = this.clientConfirmed;
        data["doubleConfirmed"] = this.doubleConfirmed;
        data["barCode"] = this.barCode;
        data["batchNo"] = this.batchNo;
        data["casNo"] = this.casNo;
        data["productionDate"] = this.productionDate ? this.productionDate.toISOString() : <any>undefined;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["locationName"] = this.locationName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseName"] = this.warehouseName;
        data["capacity"] = this.capacity;
        data["capacityUnit"] = this.capacityUnit;
        data["supplierCompanyId"] = this.supplierCompanyId;
        data["supplierCompanyName"] = this.supplierCompanyName;
        data["productionCompanyId"] = this.productionCompanyId;
        data["productionCompanyName"] = this.productionCompanyName;
        data["stockStatus"] = this.stockStatus;
        data["firstStockInTime"] = this.firstStockInTime ? this.firstStockInTime.toISOString() : <any>undefined;
        data["latestStockInTime"] = this.latestStockInTime ? this.latestStockInTime.toISOString() : <any>undefined;
        data["latestStockInUserName"] = this.latestStockInUserName;
        data["latestStockOutTime"] = this.latestStockOutTime ? this.latestStockOutTime.toISOString() : <any>undefined;
        data["latestStockOutUserName"] = this.latestStockOutUserName;
        data["retrieveTime"] = this.retrieveTime ? this.retrieveTime.toISOString() : <any>undefined;
        data["retrieveUserName"] = this.retrieveUserName;
        data["reagentId"] = this.reagentId;
        data["reagentCasNo"] = this.reagentCasNo;
        data["reagentNo"] = this.reagentNo;
        data["reagentCnName"] = this.reagentCnName;
        data["reagentCnAliasName"] = this.reagentCnAliasName;
        data["reagentEnName"] = this.reagentEnName;
        data["reagentSafeAttribute"] = this.reagentSafeAttribute;
        data["reagentStorageAttr"] = this.reagentStorageAttr;
        data["reagentPurity"] = this.reagentPurity;
        data["isDeleted"] = this.isDeleted;
        data["createUserName"] = this.createUserName;
        data["price"] = this.price;
        return data; 
    }

    clone(): ReagentStockListDto {
        const json = this.toJSON();
        let result = new ReagentStockListDto();
        result.init(json);
        return result;
    }
}

export interface IReagentStockListDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    weight: number;
    lockedOrderId: number | undefined;
    clientConfirm: boolean;
    doubleConfirm: boolean;
    clientConfirmed: boolean;
    doubleConfirmed: boolean;
    barCode: string | undefined;
    batchNo: string | undefined;
    casNo: string | undefined;
    productionDate: Date | undefined;
    expirationMonth: number;
    expirationDate: Date;
    locationName: string | undefined;
    warehouseId: number;
    warehouseName: string | undefined;
    capacity: string | undefined;
    capacityUnit: string | undefined;
    supplierCompanyId: number | undefined;
    supplierCompanyName: string | undefined;
    productionCompanyId: number | undefined;
    productionCompanyName: string | undefined;
    stockStatus: ReagentStockStatusEnum;
    firstStockInTime: Date | undefined;
    latestStockInTime: Date | undefined;
    latestStockInUserName: string | undefined;
    latestStockOutTime: Date | undefined;
    latestStockOutUserName: string | undefined;
    retrieveTime: Date | undefined;
    retrieveUserName: string | undefined;
    reagentId: number;
    reagentCasNo: string | undefined;
    reagentNo: string | undefined;
    reagentCnName: string | undefined;
    reagentCnAliasName: string | undefined;
    reagentEnName: string | undefined;
    reagentSafeAttribute: SafeAttributes;
    reagentStorageAttr: StorageAttrEnum;
    reagentPurity: string | undefined;
    isDeleted: boolean;
    createUserName: string | undefined;
    price: number;
}

export class ReagentStockListDtoPagedResultDto implements IReagentStockListDtoPagedResultDto {
    items!: ReagentStockListDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReagentStockListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ReagentStockListDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): ReagentStockListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReagentStockListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ReagentStockListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReagentStockListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReagentStockListDtoPagedResultDto {
    items: ReagentStockListDto[] | undefined;
    totalCount: number;
}

export enum ReagentStockStatusEnum {
    待入库 = 0, 
    在库 = 1, 
    离库 = 2, 
    已用完 = 3, 
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword!: string;
    userId!: number;
    newPassword!: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminPassword = data["adminPassword"];
            this.userId = data["userId"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class RoleDto implements IRoleDto {
    id!: number;
    name!: string;
    displayName!: string;
    normalizedName!: string | undefined;
    description!: string | undefined;
    grantedPermissions!: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["grantedPermissions"] && data["grantedPermissions"].constructor === Array) {
                this.grantedPermissions = [];
                for (let item of data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.grantedPermissions && this.grantedPermissions.constructor === Array) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items!: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items!: RoleDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number;
    name!: string;
    displayName!: string;
    description!: string | undefined;
    isStatic!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: Date;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: Date;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export enum SafeAttributes {
    易制毒 = 0, 
    易制爆 = 1, 
    剧毒品 = 2, 
    其它 = 3, 
}

export class SetMasterDto implements ISetMasterDto {
    userPhone!: string | undefined;
    warehouseId!: number;

    constructor(data?: ISetMasterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userPhone = data["userPhone"];
            this.warehouseId = data["warehouseId"];
        }
    }

    static fromJS(data: any): SetMasterDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetMasterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userPhone"] = this.userPhone;
        data["warehouseId"] = this.warehouseId;
        return data; 
    }

    clone(): SetMasterDto {
        const json = this.toJSON();
        let result = new SetMasterDto();
        result.init(json);
        return result;
    }
}

export interface ISetMasterDto {
    userPhone: string | undefined;
    warehouseId: number;
}

export class StockOutInputDto implements IStockOutInputDto {
    barCode!: string | undefined;
    warehouseId!: number;
    weight!: number;
    num!: number;

    constructor(data?: IStockOutInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.barCode = data["barCode"];
            this.warehouseId = data["warehouseId"];
            this.weight = data["weight"];
            this.num = data["num"];
        }
    }

    static fromJS(data: any): StockOutInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StockOutInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barCode"] = this.barCode;
        data["warehouseId"] = this.warehouseId;
        data["weight"] = this.weight;
        data["num"] = this.num;
        return data; 
    }

    clone(): StockOutInputDto {
        const json = this.toJSON();
        let result = new StockOutInputDto();
        result.init(json);
        return result;
    }
}

export interface IStockOutInputDto {
    barCode: string | undefined;
    warehouseId: number;
    weight: number;
    num: number;
}

export enum StorageAttrEnum {
    爆炸品 = 1, 
    气体_易燃 = 2, 
    气体惰性 = 3, 
    易燃固体 = 4, 
    易燃液体 = 5, 
    遇水释放易燃气体 = 6, 
    易于自燃的物质_自燃 = 7, 
    易于自燃的物质_发火 = 8, 
    氧化性物质 = 9, 
    有机过氧化物 = 10, 
    毒性物质_剧毒 = 11, 
    毒性物质_其它 = 12, 
    腐蚀性物质_酸性 = 13, 
    腐蚀性物质碱性及其它 = 14, 
    其他物质 = 15, 
}

export enum TenantAvailabilityState {
    Available = 1, 
    InActive = 2, 
    NotFound = 3, 
}

export class TenantDto implements ITenantDto {
    id!: number;
    tenancyName!: string;
    name!: string;
    isActive!: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items!: TenantDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class TenantNotificationDto implements ITenantNotificationDto {
    id!: string;
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: Date;

    constructor(data?: ITenantNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new NotificationData();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : new NotificationData();
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): TenantNotificationDto {
        const json = this.toJSON();
        let result = new TenantNotificationDto();
        result.init(json);
        return result;
    }
}

export interface ITenantNotificationDto {
    id: string;
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: Date;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateNotificationSettingsInput {
        const json = this.toJSON();
        let result = new UpdateNotificationSettingsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;
    sort!: number;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.sort = data["sort"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["sort"] = this.sort;
        return data; 
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
    sort: number;
}

export class UserDto implements IUserDto {
    id!: number;
    userName!: string;
    name!: string;
    currentSelectedWarehouseType!: WarehouseType;
    emailAddress!: string;
    isActive!: boolean;
    fullName!: string | undefined;
    lastLoginTime!: Date | undefined;
    creationTime!: Date;
    roleNames!: string[] | undefined;
    isMaster!: boolean | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.currentSelectedWarehouseType = data["currentSelectedWarehouseType"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? new Date(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.isMaster = data["isMaster"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["currentSelectedWarehouseType"] = this.currentSelectedWarehouseType;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["isMaster"] = this.isMaster;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    currentSelectedWarehouseType: WarehouseType;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: Date | undefined;
    creationTime: Date;
    roleNames: string[] | undefined;
    isMaster: boolean | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items!: UserDto[] | undefined;
    totalCount!: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserFingerDto implements IUserFingerDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    userId!: number;
    userName!: string | undefined;
    userUserName!: string | undefined;
    data1!: string | undefined;
    data2!: string | undefined;
    data3!: string | undefined;
    data4!: string | undefined;
    data5!: string | undefined;
    data6!: string | undefined;

    constructor(data?: IUserFingerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.userUserName = data["userUserName"];
            this.data1 = data["data1"];
            this.data2 = data["data2"];
            this.data3 = data["data3"];
            this.data4 = data["data4"];
            this.data5 = data["data5"];
            this.data6 = data["data6"];
        }
    }

    static fromJS(data: any): UserFingerDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFingerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userUserName"] = this.userUserName;
        data["data1"] = this.data1;
        data["data2"] = this.data2;
        data["data3"] = this.data3;
        data["data4"] = this.data4;
        data["data5"] = this.data5;
        data["data6"] = this.data6;
        return data; 
    }

    clone(): UserFingerDto {
        const json = this.toJSON();
        let result = new UserFingerDto();
        result.init(json);
        return result;
    }
}

export interface IUserFingerDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    userId: number;
    userName: string | undefined;
    userUserName: string | undefined;
    data1: string | undefined;
    data2: string | undefined;
    data3: string | undefined;
    data4: string | undefined;
    data5: string | undefined;
    data6: string | undefined;
}

export class UserFingerListDto implements IUserFingerListDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    userId!: number;
    userName!: string | undefined;
    userUserName!: string | undefined;

    constructor(data?: IUserFingerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.userUserName = data["userUserName"];
        }
    }

    static fromJS(data: any): UserFingerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFingerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userUserName"] = this.userUserName;
        return data; 
    }

    clone(): UserFingerListDto {
        const json = this.toJSON();
        let result = new UserFingerListDto();
        result.init(json);
        return result;
    }
}

export interface IUserFingerListDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    userId: number;
    userName: string | undefined;
    userUserName: string | undefined;
}

export class UserFingerListDtoPagedResultDto implements IUserFingerListDtoPagedResultDto {
    items!: UserFingerListDto[] | undefined;
    totalCount!: number;

    constructor(data?: IUserFingerListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserFingerListDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): UserFingerListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserFingerListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): UserFingerListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserFingerListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserFingerListDtoPagedResultDto {
    items: UserFingerListDto[] | undefined;
    totalCount: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    currentSelectedWarehouseType!: WarehouseType;
    isMaster!: boolean;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.currentSelectedWarehouseType = data["currentSelectedWarehouseType"];
            this.isMaster = data["isMaster"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["currentSelectedWarehouseType"] = this.currentSelectedWarehouseType;
        data["isMaster"] = this.isMaster;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    currentSelectedWarehouseType: WarehouseType;
    isMaster: boolean;
}

export class UserNotificationDto implements IUserNotificationDto {
    id!: string;
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotificationDto;

    constructor(data?: IUserNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.notification = new TenantNotificationDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotificationDto.fromJS(data["notification"]) : new TenantNotificationDto();
        }
    }

    static fromJS(data: any): UserNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UserNotificationDto {
        const json = this.toJSON();
        let result = new UserNotificationDto();
        result.init(json);
        return result;
    }
}

export interface IUserNotificationDto {
    id: string;
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotificationDto;
}

export enum UserNotificationState {
    Unread = 0, 
    Read = 1, 
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class UserToOrganizationUnitInput implements IUserToOrganizationUnitInput {
    userId!: number;
    organizationUnitId!: number;

    constructor(data?: IUserToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UserToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UserToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UserToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UserToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUserToOrganizationUnitInput {
    userId: number;
    organizationUnitId: number;
}

export class WareHouseDto implements IWareHouseDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    zhuanGuanNotifySetting!: ZhuanGuanNotifySettingEnum;
    notifySettingIntervalHour!: number;
    warehouseType!: WarehouseType;
    masterUserId!: number | undefined;
    masterUserName!: string | undefined;
    masterUserUserName!: string | undefined;
    name!: string;
    code!: string | undefined;
    address!: string | undefined;
    phone!: string | undefined;
    isActive!: boolean;
    createUserName!: string | undefined;

    constructor(data?: IWareHouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.zhuanGuanNotifySetting = data["zhuanGuanNotifySetting"];
            this.notifySettingIntervalHour = data["notifySettingIntervalHour"];
            this.warehouseType = data["warehouseType"];
            this.masterUserId = data["masterUserId"];
            this.masterUserName = data["masterUserName"];
            this.masterUserUserName = data["masterUserUserName"];
            this.name = data["name"];
            this.code = data["code"];
            this.address = data["address"];
            this.phone = data["phone"];
            this.isActive = data["isActive"];
            this.createUserName = data["createUserName"];
        }
    }

    static fromJS(data: any): WareHouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WareHouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["zhuanGuanNotifySetting"] = this.zhuanGuanNotifySetting;
        data["notifySettingIntervalHour"] = this.notifySettingIntervalHour;
        data["warehouseType"] = this.warehouseType;
        data["masterUserId"] = this.masterUserId;
        data["masterUserName"] = this.masterUserName;
        data["masterUserUserName"] = this.masterUserUserName;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["isActive"] = this.isActive;
        data["createUserName"] = this.createUserName;
        return data; 
    }

    clone(): WareHouseDto {
        const json = this.toJSON();
        let result = new WareHouseDto();
        result.init(json);
        return result;
    }
}

export interface IWareHouseDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    zhuanGuanNotifySetting: ZhuanGuanNotifySettingEnum;
    notifySettingIntervalHour: number;
    warehouseType: WarehouseType;
    masterUserId: number | undefined;
    masterUserName: string | undefined;
    masterUserUserName: string | undefined;
    name: string;
    code: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    isActive: boolean;
    createUserName: string | undefined;
}

export class WareHouseDtoPagedResultDto implements IWareHouseDtoPagedResultDto {
    items!: WareHouseDto[] | undefined;
    totalCount!: number;

    constructor(data?: IWareHouseDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(WareHouseDto.fromJS(item));
            }
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): WareHouseDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WareHouseDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): WareHouseDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WareHouseDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWareHouseDtoPagedResultDto {
    items: WareHouseDto[] | undefined;
    totalCount: number;
}

export class WarehousePermissionContainer implements IWarehousePermissionContainer {
    wareHouseName!: string | undefined;
    wareHouseId!: number;
    roleId!: number;
    item!: WarehousePermissionContainerItem[] | undefined;

    constructor(data?: IWarehousePermissionContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wareHouseName = data["wareHouseName"];
            this.wareHouseId = data["wareHouseId"];
            this.roleId = data["roleId"];
            if (data["item"] && data["item"].constructor === Array) {
                this.item = [];
                for (let item of data["item"])
                    this.item.push(WarehousePermissionContainerItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WarehousePermissionContainer {
        data = typeof data === 'object' ? data : {};
        let result = new WarehousePermissionContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wareHouseName"] = this.wareHouseName;
        data["wareHouseId"] = this.wareHouseId;
        data["roleId"] = this.roleId;
        if (this.item && this.item.constructor === Array) {
            data["item"] = [];
            for (let item of this.item)
                data["item"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WarehousePermissionContainer {
        const json = this.toJSON();
        let result = new WarehousePermissionContainer();
        result.init(json);
        return result;
    }
}

export interface IWarehousePermissionContainer {
    wareHouseName: string | undefined;
    wareHouseId: number;
    roleId: number;
    item: WarehousePermissionContainerItem[] | undefined;
}

export class WarehousePermissionContainerItem implements IWarehousePermissionContainerItem {
    permission!: WarehousePermissionEnum;
    permissionName!: string | undefined;
    isGranted!: boolean;

    constructor(data?: IWarehousePermissionContainerItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.permission = data["permission"];
            this.permissionName = data["permissionName"];
            this.isGranted = data["isGranted"];
        }
    }

    static fromJS(data: any): WarehousePermissionContainerItem {
        data = typeof data === 'object' ? data : {};
        let result = new WarehousePermissionContainerItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permission"] = this.permission;
        data["permissionName"] = this.permissionName;
        data["isGranted"] = this.isGranted;
        return data; 
    }

    clone(): WarehousePermissionContainerItem {
        const json = this.toJSON();
        let result = new WarehousePermissionContainerItem();
        result.init(json);
        return result;
    }
}

export interface IWarehousePermissionContainerItem {
    permission: WarehousePermissionEnum;
    permissionName: string | undefined;
    isGranted: boolean;
}

export class WarehousePermissionDto implements IWarehousePermissionDto {
    id!: number;
    roleId!: number;
    warehouseId!: number;
    permission!: WarehousePermissionEnum;

    constructor(data?: IWarehousePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleId = data["roleId"];
            this.warehouseId = data["warehouseId"];
            this.permission = data["permission"];
        }
    }

    static fromJS(data: any): WarehousePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarehousePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["warehouseId"] = this.warehouseId;
        data["permission"] = this.permission;
        return data; 
    }

    clone(): WarehousePermissionDto {
        const json = this.toJSON();
        let result = new WarehousePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IWarehousePermissionDto {
    id: number;
    roleId: number;
    warehouseId: number;
    permission: WarehousePermissionEnum;
}

export enum WarehousePermissionEnum {
    库存查询 = 1, 
    试剂入库 = 2, 
    试剂领用 = 3, 
    试剂归还 = 4, 
    出库单 = 5, 
}

export enum WarehouseType {
    试剂 = 1, 
    耗材 = 2, 
    办公 = 3, 
}

export enum ZhuanGuanNotifySettingEnum {
    不提醒 = 0, 
    提醒一次 = 1, 
    周期性提醒 = 2, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}